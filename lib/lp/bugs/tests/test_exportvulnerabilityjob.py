# Copyright 2025 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

from pathlib import Path

import transaction
from testtools.matchers import MatchesRegex
from zope.component import getUtility
from zope.security.proxy import removeSecurityProxy

from lp.app.enums import InformationType
from lp.app.interfaces.launchpad import ILaunchpadCelebrities
from lp.bugs.enums import VulnerabilityHandlerEnum
from lp.bugs.interfaces.cve import ICveSet
from lp.bugs.interfaces.vulnerabilityjob import (
    IExportVulnerabilityJobSource,
    VulnerabilityJobException,
    VulnerabilityJobInProgress,
)
from lp.bugs.model.exportvulnerabilityjob import ExportVulnerabilityJob
from lp.bugs.scripts.soss.sossimport import SOSSImporter
from lp.services.features.testing import FeatureFixture
from lp.services.job.interfaces.job import JobStatus
from lp.services.job.tests import block_on_job
from lp.services.librarian.model import LibraryFileAlias
from lp.testing import TestCaseWithFactory
from lp.testing.layers import CelerySlowJobLayer, LaunchpadZopelessLayer


class ExportVulnerabilityJobTests(TestCaseWithFactory):
    """Test case for ImportVulnerabilityJob."""

    layer = LaunchpadZopelessLayer

    def setUp(self):
        super().setUp()
        self.bug_importer = getUtility(ILaunchpadCelebrities).bug_importer

        self.cve_set = getUtility(ICveSet)

    @property
    def job_source(self):
        return getUtility(IExportVulnerabilityJobSource)

    def test_getOopsVars(self):
        """Test getOopsVars method."""
        handler = VulnerabilityHandlerEnum.SOSS

        job = self.job_source.create(handler)
        vars = job.getOopsVars()
        naked_job = removeSecurityProxy(job)
        self.assertIn(("vulnerabilityjob_job_id", naked_job.id), vars)
        self.assertIn(
            ("vulnerability_job_type", naked_job.job_type.title), vars
        )
        self.assertIn(("handler", naked_job.handler), vars)

    def test___repr__(self):
        """Test __repr__ method."""
        handler = VulnerabilityHandlerEnum.SOSS
        information_type = InformationType.PRIVATESECURITY.value

        metadata = {
            "request": {
                "sources": [],
                "information_type": information_type,
            },
            "result": {
                "error_description": [],
                "succeeded": [],
                "failed": [],
            },
            "data": {
                "export_link": "",
            },
        }

        job = self.job_source.create(
            handler, information_type=information_type
        )

        expected = (
            "<ExportVulnerabilityJob for "
            f"handler: {handler}, "
            f"metadata: {metadata}"
            ">"
        )
        self.assertEqual(expected, repr(job))

    def test_create_with_existing_in_progress_job(self):
        """If there's already a waiting/running ExportVulnerabilityJob for the
        handler ExportVulnerabilityJob.create() raises an exception.
        """
        handler = VulnerabilityHandlerEnum.SOSS

        # Job waiting status
        job = self.job_source.create(handler)
        waiting_exception = self.assertRaises(
            VulnerabilityJobInProgress,
            self.job_source.create,
            handler,
        )
        self.assertEqual(job, waiting_exception.job)

        # Job status from WAITING to RUNNING
        job.start()
        running_exception = self.assertRaises(
            VulnerabilityJobInProgress, self.job_source.create, handler
        )
        self.assertEqual(job, running_exception.job)

    def test_create_with_existing_completed_job(self):
        """If there's already a completed ExportVulnerabilityJob for the
        handler the job can be runned again.
        """
        handler = VulnerabilityHandlerEnum.SOSS

        job = self.job_source.create(handler)
        job.start()
        job.complete()
        self.assertEqual(job.status, JobStatus.COMPLETED)

        job_duplicated = self.job_source.create(handler)
        job_duplicated.start()
        job_duplicated.complete()
        self.assertEqual(job_duplicated.status, JobStatus.COMPLETED)

    def test_create_with_existing_failed_job(self):
        """If there's a failed ExportVulnerabilityJob for the handler the job
        can be runned again.
        """
        handler = VulnerabilityHandlerEnum.SOSS

        job = self.job_source.create(handler)
        job.start()
        job.fail()
        self.assertEqual(job.status, JobStatus.FAILED)

        job_duplicated = self.job_source.create(handler)
        job_duplicated.start()
        job_duplicated.complete()
        self.assertEqual(job_duplicated.status, JobStatus.COMPLETED)

    def test_create_with_existing_suspended_job(self):
        """If there's a suspended ExportVulnerabilityJob for the handler the
        job can be runned again.
        """
        handler = VulnerabilityHandlerEnum.SOSS

        job = self.job_source.create(handler)
        job.start()
        job.suspend()
        self.assertEqual(job.status, JobStatus.SUSPENDED)

        job_duplicated = self.job_source.create(handler)
        job_duplicated.start()
        job_duplicated.complete()
        self.assertEqual(job_duplicated.status, JobStatus.COMPLETED)

    def test_arguments(self):
        """Test that ExportVulnerabilityJob specified with arguments can
        be gotten out again."""

        handler = VulnerabilityHandlerEnum.SOSS
        information_type = InformationType.PRIVATESECURITY.value

        metadata = {
            "request": {
                "sources": ["https://launchpad.net/ubuntu"],
                "information_type": information_type,
            },
            "result": {
                "error_description": [],
                "succeeded": [],
                "failed": [],
            },
            "data": {
                "export_link": "",
            },
        }

        job = self.job_source.create(
            handler,
            sources=["https://launchpad.net/ubuntu"],
            information_type=information_type,
        )

        naked_job = removeSecurityProxy(job)
        self.assertEqual(naked_job.handler, handler)

        self.assertEqual(naked_job.metadata, metadata)

    def test_run_with_no_CVEs(self):
        """
        Run ExportVulnerabilityJob but with no CVE that also has its bug and
        vulnerability.

        Note: Since we use the database to look for CVE sequence names, the
        dev environment's sample database must have no CVEs with bugs and
        vulnerabilities for this test to pass. If they ever get added, the
        test will need to be updated to use a different approach.
        """

        self.factory.makeDistribution(name="soss")

        job = self.job_source.create(handler=VulnerabilityHandlerEnum.SOSS)

        self.assertRaisesWithContent(
            VulnerabilityJobException, "No CVEs to export", job.run
        )

    def _put_cve_in_soss(self):
        self.factory.makePerson(name="octagalland")
        soss = removeSecurityProxy(
            self.factory.makeDistribution(
                name="soss",
                displayname="SOSS",
                information_type=InformationType.PROPRIETARY,
            )
        )

        sampledata = (
            Path(__file__).parent.parent / "scripts/soss/tests/sampledata"
        )

        soss_importer = SOSSImporter(soss)

        imported_list = []
        for file in sampledata.iterdir():
            cve_sequence = file.name.lstrip("CVE-")
            if not self.cve_set[cve_sequence]:
                self.factory.makeCVE(sequence=cve_sequence)

            bug, vulnerability = soss_importer.import_cve_from_file(file)
            imported_list.append((cve_sequence, bug, vulnerability))

        return imported_list

    def test_run_export(self):
        """Run ExportVulnerabilityJob."""
        imported_list = self._put_cve_in_soss()
        information_type = InformationType.PRIVATESECURITY.value
        export_link = "http://example.com/fake-url"

        self.patch(
            LibraryFileAlias,
            "getURL",
            lambda self: export_link,
        )

        job = self.job_source.create(
            handler=VulnerabilityHandlerEnum.SOSS,
            information_type=information_type,
        )

        job.run()

        cve_names = [
            f"CVE-{cve_sequence}" for cve_sequence, _, _ in imported_list
        ]

        naked_job_metadata = removeSecurityProxy(job.metadata)
        naked_job_metadata["result"]["succeeded"].sort()
        cve_names.sort()

        self.assertEqual(
            naked_job_metadata,
            {
                "request": {
                    "sources": [],
                    "information_type": information_type,
                },
                "result": {
                    "error_description": [],
                    "succeeded": cve_names,
                    "failed": [],
                },
                "data": {
                    "export_link": export_link,
                },
            },
        )

    def test_get(self):
        """ExportVulnerabilityJob.get() returns the import job for the given
        handler.
        """
        handler = VulnerabilityHandlerEnum.SOSS

        # There is no job before creating it
        self.assertIs(None, self.job_source.get(handler))

        job = self.job_source.create(handler)
        job_gotten = self.job_source.get(handler)

        self.assertIsInstance(job, ExportVulnerabilityJob)
        self.assertEqual(job, job_gotten)

    def test_error_description_when_no_error(self):
        """The ExportVulnerabilityJob.error_description property returns
        None when no error description is recorded."""
        handler = VulnerabilityHandlerEnum.SOSS
        information_type = InformationType.PRIVATESECURITY.value

        job = self.job_source.create(
            handler,
            information_type=information_type,
        )
        self.assertEqual([], removeSecurityProxy(job).error_description)

    def test_error_description_set_when_notifying_about_user_errors(self):
        """Test that error_description is set by notifyUserError()."""
        handler = VulnerabilityHandlerEnum.SOSS
        information_type = InformationType.PRIVATESECURITY.value

        job = self.job_source.create(
            handler,
            information_type=information_type,
        )
        message = "This is an example message."
        job.notifyUserError(VulnerabilityJobException(message))
        self.assertEqual([message], removeSecurityProxy(job).error_description)


class ExportVulnerabilityTestViaCelery(TestCaseWithFactory):
    layer = CelerySlowJobLayer

    def setUp(self):
        super().setUp()

        self.bug_importer = getUtility(ILaunchpadCelebrities).bug_importer
        self.cve_set = getUtility(ICveSet)

    def _put_cve_in_soss(self):
        self.factory.makePerson(name="octagalland")
        soss = removeSecurityProxy(
            self.factory.makeDistribution(
                name="soss",
                displayname="SOSS",
                information_type=InformationType.PROPRIETARY,
            )
        )

        sampledata = (
            Path(__file__).parent.parent / "scripts/soss/tests/sampledata"
        )

        soss_importer = SOSSImporter(soss)

        imported_list = []
        for file in sampledata.iterdir():
            cve_sequence = (
                file.name[4:] if file.name.startswith("CVE-") else file.name
            )
            if not self.cve_set[cve_sequence]:
                self.factory.makeCVE(sequence=cve_sequence)

            bug, vulnerability = soss_importer.import_cve_from_file(file)
            imported_list.append((cve_sequence, bug, vulnerability))

        return imported_list

    def test_job(self):
        """Job runs via Celery."""
        fixture = FeatureFixture(
            {
                "jobs.celery.enabled_classes": "ExportVulnerabilityJob",
            }
        )
        self.useFixture(fixture)

        imported_list = self._put_cve_in_soss()
        transaction.commit()

        job_source = getUtility(IExportVulnerabilityJobSource)

        handler = VulnerabilityHandlerEnum.SOSS
        information_type = InformationType.PRIVATESECURITY.value
        with block_on_job():
            job_source.create(
                handler,
                information_type=information_type,
            )
            transaction.commit()

        cve_names = [
            f"CVE-{cve_sequence}" for cve_sequence, _, _ in imported_list
        ]

        job = job_source.get(handler)

        naked_job_metadata = removeSecurityProxy(job.metadata)
        naked_job_metadata["result"]["succeeded"].sort()
        cve_names.sort()

        metadata_request = {
            "sources": [],
            "information_type": information_type,
        }

        metadata_result = {
            "error_description": [],
            "succeeded": cve_names,
            "failed": [],
        }

        self.assertEqual(handler, job.handler)
        self.assertEqual(metadata_request, naked_job_metadata["request"])
        self.assertEqual(metadata_result, naked_job_metadata["result"])

        self.assertThat(
            naked_job_metadata["data"]["export_link"],
            MatchesRegex(
                r".*exported_vulnerabilities_[0-9]+\.zip$",
            ),
        )
