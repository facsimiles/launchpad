# Copyright 2025 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

from pathlib import Path

import transaction
from testscenarios.testcase import WithScenarios
from testtools.matchers import MatchesRegex
from zope.component import getUtility
from zope.security.proxy import removeSecurityProxy

from lp.app.enums import InformationType
from lp.app.interfaces.launchpad import ILaunchpadCelebrities
from lp.bugs.enums import VulnerabilityHandlerEnum
from lp.bugs.interfaces.cve import ICveSet
from lp.bugs.interfaces.vulnerabilityjob import (
    IExportVulnerabilityJobSource,
    VulnerabilityJobException,
    VulnerabilityJobInProgress,
)
from lp.bugs.model.exportvulnerabilityjob import ExportVulnerabilityJob
from lp.bugs.scripts.soss.sossimport import SOSSImporter
from lp.bugs.scripts.uctimport import UCTImporter
from lp.services.features.testing import FeatureFixture
from lp.services.job.interfaces.job import JobStatus
from lp.services.job.tests import block_on_job
from lp.services.librarian.model import LibraryFileAlias
from lp.testing import TestCaseWithFactory
from lp.testing.layers import CelerySlowJobLayer, LaunchpadZopelessLayer


class ExportVulnerabilityJobTests(WithScenarios, TestCaseWithFactory):
    """Test case for ImportVulnerabilityJob."""

    layer = LaunchpadZopelessLayer

    scenarios = [
        ("soss", {"handler_name": "SOSS"}),
        ("uct", {"handler_name": "UCT"}),
    ]

    def setUp(self):
        super().setUp()
        self.bug_importer = getUtility(ILaunchpadCelebrities).bug_importer

        self.cve_set = getUtility(ICveSet)

        if self.handler_name == "SOSS":
            self.handler = VulnerabilityHandlerEnum.SOSS
            self.distribution = removeSecurityProxy(
                self.factory.makeDistribution(
                    name="soss",
                    displayname="SOSS",
                    information_type=InformationType.PROPRIETARY,
                )
            )
        elif self.handler_name == "UCT":
            self.handler = VulnerabilityHandlerEnum.UCT
            celebrities = getUtility(ILaunchpadCelebrities)
            self.distribution = removeSecurityProxy(celebrities.ubuntu)

            # Create objects to match the sample data
            series_names = [
                "artful",
                "bionic",
                "cosmic",
                "dapper",
                "disco",
                "edgy",
                "eoan",
                "feisty",
                "focal",
                "groovy",
                "gutsy",
                "hardy",
                "hirsute",
                "impish",
                "intrepid",
                "jammy",
                "jaunty",
                "karmic",
                "kinetic",
                "lucid",
                "maverick",
                "natty",
                "oneiric",
                "precise",
                "quantal",
                "raring",
                "saucy",
                "trusty",
                "utopic",
                "vivid",
                "wily",
                "xenial",
                "yakkety",
                "zesty",
            ]
            for name in series_names:
                self.factory.makeDistroSeries(
                    name=name,
                    distribution=self.distribution,
                )

            distroseries = self.factory.makeDistroSeries(
                name="questing",
                distribution=self.distribution,
            )

            package_names = [
                "linux",
                "linux-hwe",
                "gnupg2",
                "xine-ui",
                "gnupg",
                "gbrowse",
            ]
            for name in package_names:
                sourcepackagename = self.factory.makeSourcePackageName(name)
                self.factory.makeSourcePackage(
                    distroseries=distroseries,
                    publish=True,
                    sourcepackagename=sourcepackagename,
                )

    @property
    def job_source(self):
        return getUtility(IExportVulnerabilityJobSource)

    def test_getOopsVars(self):
        """Test getOopsVars method."""
        job = self.job_source.create(self.handler)
        vars = job.getOopsVars()
        naked_job = removeSecurityProxy(job)
        self.assertIn(("vulnerabilityjob_job_id", naked_job.id), vars)
        self.assertIn(
            ("vulnerability_job_type", naked_job.job_type.title), vars
        )
        self.assertIn(("handler", naked_job.handler), vars)

    def test___repr__(self):
        """Test __repr__ method."""
        metadata = {
            "request": {
                "sources": [],
            },
            "result": {
                "error_description": [],
                "succeeded": [],
                "failed": [],
                "export_link": "",
            },
        }

        job = self.job_source.create(self.handler)

        expected = (
            "<ExportVulnerabilityJob for "
            f"handler: {self.handler}, "
            f"metadata: {metadata}"
            ">"
        )
        self.assertEqual(expected, repr(job))

    def test_create_with_existing_in_progress_job(self):
        """If there's already a waiting/running ExportVulnerabilityJob for the
        handler ExportVulnerabilityJob.create() raises an exception.
        """
        # Job waiting status
        job = self.job_source.create(self.handler)
        waiting_exception = self.assertRaises(
            VulnerabilityJobInProgress,
            self.job_source.create,
            self.handler,
        )
        self.assertEqual(job, waiting_exception.job)

        # Job status from WAITING to RUNNING
        job.start()
        running_exception = self.assertRaises(
            VulnerabilityJobInProgress, self.job_source.create, self.handler
        )
        self.assertEqual(job, running_exception.job)

    def test_create_with_existing_completed_job(self):
        """If there's already a completed ExportVulnerabilityJob for the
        handler the job can be runned again.
        """
        job = self.job_source.create(self.handler)
        job.start()
        job.complete()
        self.assertEqual(job.status, JobStatus.COMPLETED)

        job_duplicated = self.job_source.create(self.handler)
        job_duplicated.start()
        job_duplicated.complete()
        self.assertEqual(job_duplicated.status, JobStatus.COMPLETED)

    def test_create_with_existing_failed_job(self):
        """If there's a failed ExportVulnerabilityJob for the handler the job
        can be runned again.
        """
        job = self.job_source.create(self.handler)
        job.start()
        job.fail()
        self.assertEqual(job.status, JobStatus.FAILED)

        job_duplicated = self.job_source.create(self.handler)
        job_duplicated.start()
        job_duplicated.complete()
        self.assertEqual(job_duplicated.status, JobStatus.COMPLETED)

    def test_create_with_existing_suspended_job(self):
        """If there's a suspended ExportVulnerabilityJob for the handler the
        job can be runned again.
        """
        job = self.job_source.create(self.handler)
        job.start()
        job.suspend()
        self.assertEqual(job.status, JobStatus.SUSPENDED)

        job_duplicated = self.job_source.create(self.handler)
        job_duplicated.start()
        job_duplicated.complete()
        self.assertEqual(job_duplicated.status, JobStatus.COMPLETED)

    def test_arguments(self):
        """Test that ExportVulnerabilityJob specified with arguments can
        be gotten out again."""

        metadata = {
            "request": {
                "sources": ["https://launchpad.net/ubuntu"],
            },
            "result": {
                "error_description": [],
                "succeeded": [],
                "failed": [],
                "export_link": "",
            },
        }

        job = self.job_source.create(
            self.handler,
            sources=["https://launchpad.net/ubuntu"],
        )

        naked_job = removeSecurityProxy(job)
        self.assertEqual(naked_job.handler, self.handler)

        self.assertEqual(naked_job.metadata, metadata)

    def test_run_with_no_CVEs(self):
        """
        Run ExportVulnerabilityJob but with no CVE that also has its bug and
        vulnerability.

        Note: Since we use the database to look for CVE sequence names, the
        dev environment's sample database must have no CVEs with bugs and
        vulnerabilities for this test to pass. If they ever get added, the
        test will need to be updated to use a different approach.
        """
        job = self.job_source.create(handler=self.handler)

        self.assertRaisesWithContent(
            VulnerabilityJobException, "No CVEs to export", job.run
        )

    def _create_test_cve(self):
        self.factory.makePerson(name="octagalland")

        if self.handler_name == "SOSS":
            sampledata_path = "scripts/soss/tests/sampledata"
            importer = SOSSImporter(self.distribution)

        elif self.handler_name == "UCT":
            sampledata_path = "scripts/uct/tests/sampledata"
            importer = UCTImporter(self.distribution)

        sampledata = Path(__file__).parent.parent / sampledata_path

        imported_list = []
        for file in sampledata.iterdir():
            cve_sequence = file.name.lstrip("CVE-")
            if not self.cve_set[cve_sequence]:
                self.factory.makeCVE(sequence=cve_sequence)

            bug, vulnerability, _ = importer.import_cve_from_file(file)
            imported_list.append((cve_sequence, bug, vulnerability))

        return imported_list

    def test_run_export(self):
        """Run ExportVulnerabilityJob."""
        imported_list = self._create_test_cve()
        export_link = "http://example.com/fake-url"

        self.patch(
            LibraryFileAlias,
            "getURL",
            lambda self: export_link,
        )

        job = self.job_source.create(handler=self.handler)

        job.run()

        cve_names = [
            f"CVE-{cve_sequence}" for cve_sequence, _, _ in imported_list
        ]

        naked_job_metadata = removeSecurityProxy(job.metadata)
        naked_job_metadata["result"]["succeeded"].sort()
        cve_names.sort()

        self.assertEqual(
            naked_job_metadata,
            {
                "request": {
                    "sources": [],
                },
                "result": {
                    "error_description": [],
                    "succeeded": cve_names,
                    "failed": [],
                    "export_link": export_link,
                },
            },
        )

    def test_get(self):
        """ExportVulnerabilityJob.get() returns the import job for the given
        handler.
        """

        # There is no job before creating it
        self.assertIs(None, self.job_source.get(self.handler))

        job = self.job_source.create(self.handler)
        job_gotten = self.job_source.get(self.handler)

        self.assertIsInstance(job, ExportVulnerabilityJob)
        self.assertEqual(job, job_gotten)

    def test_error_description_when_no_error(self):
        """The ExportVulnerabilityJob.error_description property returns
        None when no error description is recorded."""

        job = self.job_source.create(self.handler)
        self.assertEqual([], removeSecurityProxy(job).error_description)

    def test_error_description_set_when_notifying_about_user_errors(self):
        """Test that error_description is set by notifyUserError()."""

        job = self.job_source.create(self.handler)
        message = "This is an example message."
        job.notifyUserError(VulnerabilityJobException(message))
        self.assertEqual([message], removeSecurityProxy(job).error_description)


class ExportVulnerabilityTestViaCelery(WithScenarios, TestCaseWithFactory):
    layer = CelerySlowJobLayer

    scenarios = [
        ("soss", {"handler_name": "SOSS"}),
        ("uct", {"handler_name": "UCT"}),
    ]

    def setUp(self):
        super().setUp()

        self.bug_importer = getUtility(ILaunchpadCelebrities).bug_importer
        self.cve_set = getUtility(ICveSet)

        if self.handler_name == "SOSS":
            self.handler = VulnerabilityHandlerEnum.SOSS
            self.distribution = removeSecurityProxy(
                self.factory.makeDistribution(
                    name="soss",
                    displayname="SOSS",
                    information_type=InformationType.PROPRIETARY,
                )
            )

        elif self.handler_name == "UCT":
            self.handler = VulnerabilityHandlerEnum.UCT
            celebrities = getUtility(ILaunchpadCelebrities)
            self.distribution = removeSecurityProxy(celebrities.ubuntu)

            # Create objects to match the sample data
            series_names = [
                "artful",
                "bionic",
                "cosmic",
                "dapper",
                "disco",
                "edgy",
                "eoan",
                "feisty",
                "focal",
                "groovy",
                "gutsy",
                "hardy",
                "hirsute",
                "impish",
                "intrepid",
                "jammy",
                "jaunty",
                "karmic",
                "kinetic",
                "lucid",
                "maverick",
                "natty",
                "oneiric",
                "precise",
                "quantal",
                "raring",
                "saucy",
                "trusty",
                "utopic",
                "vivid",
                "wily",
                "xenial",
                "yakkety",
                "zesty",
            ]
            for name in series_names:
                self.factory.makeDistroSeries(
                    name=name,
                    distribution=self.distribution,
                )

            distroseries = self.factory.makeDistroSeries(
                name="questing",
                distribution=self.distribution,
            )

            package_names = [
                "linux",
                "linux-hwe",
                "gnupg2",
                "xine-ui",
                "gnupg",
                "gbrowse",
            ]
            for name in package_names:
                sourcepackagename = self.factory.makeSourcePackageName(name)
                self.factory.makeSourcePackage(
                    distroseries=distroseries,
                    publish=True,
                    sourcepackagename=sourcepackagename,
                )

    def _create_test_cve(self):
        self.factory.makePerson(name="octagalland")

        if self.handler_name == "SOSS":
            sampledata_path = "scripts/soss/tests/sampledata"
            importer = SOSSImporter(self.distribution)

        elif self.handler_name == "UCT":
            sampledata_path = "scripts/uct/tests/sampledata"
            importer = UCTImporter(self.distribution)

        sampledata = Path(__file__).parent.parent / sampledata_path

        imported_list = []
        for file in sampledata.iterdir():
            cve_sequence = (
                file.name[4:] if file.name.startswith("CVE-") else file.name
            )
            if not self.cve_set[cve_sequence]:
                self.factory.makeCVE(sequence=cve_sequence)

            bug, vulnerability, _ = importer.import_cve_from_file(file)
            imported_list.append((cve_sequence, bug, vulnerability))

        return imported_list

    def test_job(self):
        """Job runs via Celery."""
        fixture = FeatureFixture(
            {
                "jobs.celery.enabled_classes": "ExportVulnerabilityJob",
            }
        )
        self.useFixture(fixture)

        imported_list = self._create_test_cve()
        transaction.commit()

        job_source = getUtility(IExportVulnerabilityJobSource)

        with block_on_job():
            job_source.create(self.handler)
            transaction.commit()

        cve_names = [
            f"CVE-{cve_sequence}" for cve_sequence, _, _ in imported_list
        ]

        job = job_source.get(self.handler)

        naked_job_metadata = removeSecurityProxy(job.metadata)
        naked_job_metadata["result"]["succeeded"].sort()
        cve_names.sort()

        metadata_request = {
            "sources": [],
        }

        self.assertEqual(self.handler, job.handler)
        self.assertEqual(metadata_request, naked_job_metadata["request"])
        self.assertEqual([], naked_job_metadata["result"]["error_description"])
        self.assertEqual(cve_names, naked_job_metadata["result"]["succeeded"])
        self.assertEqual([], naked_job_metadata["result"]["failed"])

        self.assertThat(
            naked_job_metadata["result"]["export_link"],
            MatchesRegex(
                r".*exported_vulnerabilities_[0-9]+\.zip$",
            ),
        )
