# Copyright 2025 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

__all__ = [
    "ImportVulnerabilityJob",
]

import logging
import re
from datetime import datetime, timedelta, timezone

from zope.component import getUtility
from zope.interface import implementer, provider
from zope.security.proxy import removeSecurityProxy

from lp.app.enums import InformationType
from lp.bugs.enums import VulnerabilityHandlerEnum
from lp.bugs.interfaces.vulnerabilityjob import (
    IImportVulnerabilityJob,
    IImportVulnerabilityJobSource,
    VulnerabilityJobException,
    VulnerabilityJobInProgress,
    VulnerabilityJobType,
)
from lp.bugs.model.vulnerabilityjob import (
    VulnerabilityJob,
    VulnerabilityJobDerived,
)
from lp.bugs.scripts.soss.models import SOSSRecord
from lp.bugs.scripts.soss.sossimport import SOSSImporter
from lp.bugs.scripts.uct.models import UCTRecord
from lp.bugs.scripts.uct.uctimport import UCTImporter
from lp.code.errors import GitRepositoryBlobNotFound, GitRepositoryScanFault
from lp.code.interfaces.githosting import IGitHostingClient
from lp.code.interfaces.gitlookup import IGitLookup
from lp.code.model.githosting import RequestExceptionWrapper
from lp.registry.interfaces.distribution import IDistributionSet
from lp.services.config import config
from lp.services.database.interfaces import IPrimaryStore, IStore
from lp.services.job.interfaces.job import JobStatus
from lp.services.job.model.job import Job
from lp.services.timeout import override_timeout

CVE_PATTERN = re.compile(r"^CVE-\d{4}-\d+$")
logger = logging.getLogger(__name__)


@implementer(IImportVulnerabilityJob)
@provider(IImportVulnerabilityJobSource)
class ImportVulnerabilityJob(VulnerabilityJobDerived):
    class_job_type = VulnerabilityJobType.IMPORT_DATA

    user_error_types = (VulnerabilityJobException,)

    # This is a known slow task that will exceed the timeouts for
    # the normal job queue, so put it on a queue with longer timeouts
    task_queue = "launchpad_job_slow"

    soft_time_limit = timedelta(minutes=120)
    lease_duration = timedelta(minutes=120)

    config = config.IImportVulnerabilityJobSource

    @property
    def git_repository(self):
        return self.metadata.get("request").get("git_repository")

    @property
    def git_ref(self):
        return self.metadata.get("request").get("git_ref")

    @property
    def git_paths(self):
        return self.metadata.get("request").get("git_paths")

    @property
    def information_type(self):
        return self.metadata.get("request").get("information_type")

    @property
    def import_since_commit_sha1(self):
        return self.metadata.get("request").get("import_since_commit_sha1")

    @property
    def error_description(self):
        return self.metadata.get("result").get("error_description")

    @classmethod
    def create(
        cls,
        handler,
        git_repository,
        git_ref,
        git_paths,
        information_type,
        import_since_commit_sha1=False,
    ):
        """Create a new `ImportVulnerabilityJob`.

        :param handler: What handler to use for importing the data. Can be one
             of a group of predefined classes (SOSS, UCT, ...).
        :param git_repository: Git repository to import from.
        :param git_ref: Git branch/tag to get data from.
        :param git_paths: List of relative directories within the repository to
            get data from.
        :param information_type: Whether imported data (bugs) should be private
            or public. Can be one of a group of predefined options (PUBLIC,
            PRIVATE_SECURITY...). If the source git repository is private, then
            the information_type needs to be private also.
        :param import_since_commit_sha1: Import data from files that were
            altered since the given commit_sha1
        """
        store = IPrimaryStore(VulnerabilityJob)

        vulnerability_job = store.find(
            VulnerabilityJob,
            VulnerabilityJob.job_id == Job.id,
            VulnerabilityJob.job_type == cls.class_job_type,
            VulnerabilityJob.handler == handler,
            Job._status.is_in((JobStatus.WAITING, JobStatus.RUNNING)),
            # If the job was scheduled more than twice the time limit of the
            # job, we allow a new one to be created.
            Job.date_created
            > datetime.now(timezone.utc) - 2 * cls.soft_time_limit,
        ).one()

        if vulnerability_job is not None:
            raise VulnerabilityJobInProgress(cls(vulnerability_job))

        # Schedule the initialization.
        metadata = {
            "request": {
                "git_repository": git_repository,
                "git_ref": git_ref,
                "git_paths": git_paths,
                "information_type": information_type,
                "import_since_commit_sha1": import_since_commit_sha1,
            },
            "result": {
                "error_description": [],
                "created": [],
                "updated": [],
                "failed": [],
            },
        }

        vulnerability_job = VulnerabilityJob(
            handler, cls.class_job_type, metadata
        )
        store.add(vulnerability_job)
        derived_job = cls(vulnerability_job)
        derived_job.celeryRunOnCommit()
        IStore(VulnerabilityJob).flush()
        return derived_job

    @classmethod
    def get(cls, handler):
        """See `IImportVulnerabilityJob`."""
        vulnerability_job = (
            IStore(VulnerabilityJob)
            .find(
                VulnerabilityJob,
                VulnerabilityJob.job_id == Job.id,
                VulnerabilityJob.job_type == cls.class_job_type,
                VulnerabilityJob.handler == handler,
            )
            .one()
        )
        return None if vulnerability_job is None else cls(vulnerability_job)

    def __repr__(self):
        """Returns an informative representation of the job."""
        parts = "%s for" % self.__class__.__name__
        parts += " handler: %s" % self.handler
        parts += ", metadata: %s" % self.metadata
        return "<%s>" % parts

    def _get_parser_importer(
        self,
        handler: VulnerabilityHandlerEnum,
        information_type: InformationType,
    ):
        """Decide which parser and importer to use

        :return: a tuple of (parser, importer) where parser is the function
        that gets a blob and returns a record and importer is the function that
        gets a record and imports it.
        """

        if handler == VulnerabilityHandlerEnum.SOSS:
            distribution = removeSecurityProxy(
                getUtility(IDistributionSet).getByName("soss")
            )
            parser = SOSSRecord
            importer = SOSSImporter(
                distribution, information_type=information_type
            )
        elif handler == VulnerabilityHandlerEnum.UCT:
            distribution = getUtility(IDistributionSet).getByName("ubuntu")
            parser = UCTRecord
            importer = UCTImporter(
                distribution, information_type=information_type
            )
        else:
            self._notify_and_raise("Handler not found")

        return parser, importer

    def _notify_and_raise(self, message: str):
        """Creates, notifies, and raises a VulnerabilityJobException."""
        exception = VulnerabilityJobException(message)
        self.notifyUserError(exception)
        raise exception

    def _get_git_repository(self, git_repository_id):
        git_lookup = getUtility(IGitLookup)
        repository = removeSecurityProxy(git_lookup.get(git_repository_id))
        if not repository:
            self._notify_and_raise("Git repository not found")
        return repository

    def _get_git_reference(self, repository, git_ref_path):
        ref = removeSecurityProxy(repository.getRefByPath(git_ref_path))
        if not ref:
            self._notify_and_raise("Git ref not found")
        return ref

    def _get_changed_files(self, repository, ref):
        try:
            stats = getUtility(IGitHostingClient).getDiffStats(
                path=repository.getInternalPath(),
                old=self.import_since_commit_sha1,
                new=ref.commit_sha1,
                logger=logger,
            )
        except GitRepositoryScanFault:
            message = (
                f"Git diff between {self.import_since_commit_sha1} and "
                f"{ref.commit_sha1} for {self.git_ref} not found"
            )
            self._notify_and_raise(message)

        files = [*stats.get("added", ()), *stats.get("modified", ())]
        return files

    def _is_valid_file(self, file, cve_sequence, valid_paths):
        if not file.startswith(valid_paths):
            return False

        if not CVE_PATTERN.match(cve_sequence):
            logger.debug(
                f"[ImportVulnerabilityJob] {cve_sequence} is not a CVE "
                "sequence"
            )
            return False
        return True

    def run(self):
        """See `IRunnableJob`."""
        # InformationType is passed as a value as DBItem is not serializable
        information_type = InformationType.items[self.information_type]
        parser, importer = self._get_parser_importer(
            self.context.handler, information_type
        )

        # Get git repository
        repository = self._get_git_repository(self.git_repository)

        # Get git reference
        ref = self._get_git_reference(repository, self.git_ref)

        # turnip API call to get added/modified files
        files = self._get_changed_files(repository, ref)
        valid_paths = tuple(self.git_paths)

        for file in files:
            # Check if files that changed are in the desired path
            cve_sequence = file.rsplit("/", maxsplit=1)[-1]
            if not self._is_valid_file(file, cve_sequence, valid_paths):
                continue

            success = False
            try:
                logger.debug(f"[ImportVulnerabilityJob] Getting {file}")

                with override_timeout(self.config.getblob_timeout):
                    blob = ref.getBlob(file)

                logger.debug(
                    f"[ImportVulnerabilityJob] Parsing {cve_sequence}"
                )
                record = parser.from_str(blob)

                bug, vulnerability, created = importer.from_record(
                    record, cve_sequence
                )

                if bug and vulnerability:
                    success = True
                    if created:
                        self.metadata["result"]["created"].append(cve_sequence)
                    else:
                        self.metadata["result"]["updated"].append(cve_sequence)
            except (
                GitRepositoryScanFault,
                GitRepositoryBlobNotFound,
                RequestExceptionWrapper,
            ) as e:
                # If there is a problem with git repository API call, we stop
                # as we won't be able to fetch more files
                message = (
                    f"Failed to get file from Git repository: {file}."
                    f"Aborting. {e}"
                )
                self._notify_and_raise(message)
            except Exception as e:
                self.notifyUserError(f"{cve_sequence}: {e}")
            finally:
                if not success:
                    self.metadata["result"]["failed"].append(cve_sequence)

    def notifyUserError(self, error):
        """Calls up and also saves the error text in this job's metadata.

        See `BaseRunnableJob`.
        """
        # This method is called when error is an instance of
        # self.user_error_types.
        super().notifyUserError(error)
        logger.error(error)
        error_description = self.metadata.get("result").get(
            "error_description", []
        )
        error_description.append(str(error))
        self.metadata["result"]["error_description"] = error_description

    def getOopsVars(self):
        """See `IRunnableJob`."""
        vars = super().getOopsVars()
        vars.extend(
            [
                ("vulnerabilityjob_job_id", self.context.id),
                ("vulnerability_job_type", self.context.job_type.title),
                ("handler", self.context.handler),
            ]
        )
        return vars
