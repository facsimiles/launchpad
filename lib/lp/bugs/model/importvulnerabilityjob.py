# Copyright 2025 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

__all__ = [
    "ImportVulnerabilityJob",
]

import logging
import re

from zope.component import getUtility
from zope.interface import implementer, provider
from zope.security.proxy import removeSecurityProxy

from lp.app.enums import InformationType
from lp.bugs.enums import VulnerabilityHandlerEnum
from lp.bugs.interfaces.vulnerabilityjob import (
    IImportVulnerabilityJob,
    IImportVulnerabilityJobSource,
    VulnerabilityJobException,
    VulnerabilityJobInProgress,
    VulnerabilityJobType,
)
from lp.bugs.model.vulnerabilityjob import (
    VulnerabilityJob,
    VulnerabilityJobDerived,
)
from lp.bugs.scripts.soss.models import SOSSRecord
from lp.bugs.scripts.soss.sossimport import SOSSImporter
from lp.code.errors import GitRepositoryBlobNotFound, GitRepositoryScanFault
from lp.code.interfaces.githosting import IGitHostingClient
from lp.code.interfaces.gitlookup import IGitLookup
from lp.services.config import config
from lp.services.database.interfaces import IPrimaryStore, IStore
from lp.services.job.interfaces.job import JobStatus
from lp.services.job.model.job import Job

CVE_PATTERN = re.compile(r"^CVE-\d{4}-\d+$")
logger = logging.getLogger(__name__)


@implementer(IImportVulnerabilityJob)
@provider(IImportVulnerabilityJobSource)
class ImportVulnerabilityJob(VulnerabilityJobDerived):
    class_job_type = VulnerabilityJobType.IMPORT_DATA

    user_error_types = (VulnerabilityJobException,)

    task_queue = "launchpad_job_slow"

    config = config.IImportVulnerabilityJobSource

    @property
    def git_repository(self):
        return self.metadata.get("request").get("git_repository")

    @property
    def git_ref(self):
        return self.metadata.get("request").get("git_ref")

    @property
    def git_paths(self):
        return self.metadata.get("request").get("git_paths")

    @property
    def information_type(self):
        return self.metadata.get("request").get("information_type")

    @property
    def import_since_commit_sha1(self):
        return self.metadata.get("request").get("import_since_commit_sha1")

    @property
    def error_description(self):
        return self.metadata.get("result").get("error_description")

    @classmethod
    def create(
        cls,
        handler,
        git_repository,
        git_ref,
        git_paths,
        information_type,
        import_since_commit_sha1=False,
    ):
        """Create a new `ImportVulnerabilityJob`.

        :param handler: What handler to use for importing the data. Can be one
             of a group of predefined classes (SOSS, UCT, ...).
        :param git_repository: Git repository to import from.
        :param git_ref: Git branch/tag to get data from.
        :param git_paths: List of relative directories within the repository to
            get data from.
        :param information_type: Whether imported data (bugs) should be private
            or public. Can be one of a group of predefined options (PUBLIC,
            PRIVATE_SECURITY...). If the source git repository is private, then
            the information_type needs to be private also.
        :param import_since_commit_sha1: Import data from files that were
            altered since the given commit_sha1
        """
        store = IPrimaryStore(VulnerabilityJob)

        vulnerability_job = store.find(
            VulnerabilityJob,
            VulnerabilityJob.job_id == Job.id,
            VulnerabilityJob.job_type == cls.class_job_type,
            VulnerabilityJob.handler == handler,
            Job._status.is_in(
                (JobStatus.WAITING, JobStatus.RUNNING, JobStatus.SUSPENDED)
            ),
        ).one()

        if vulnerability_job is not None:
            raise VulnerabilityJobInProgress(cls(vulnerability_job))

        # Schedule the initialization.
        metadata = {
            "request": {
                "git_repository": git_repository,
                "git_ref": git_ref,
                "git_paths": git_paths,
                "information_type": information_type,
                "import_since_commit_sha1": import_since_commit_sha1,
            },
            "result": {
                "error_description": [],
                "succeeded": [],
                "failed": [],
            },
        }

        vulnerability_job = VulnerabilityJob(
            handler, cls.class_job_type, metadata
        )
        store.add(vulnerability_job)
        derived_job = cls(vulnerability_job)
        derived_job.celeryRunOnCommit()
        IStore(VulnerabilityJob).flush()
        return derived_job

    @classmethod
    def get(cls, handler):
        """See `IImportVulnerabilityJob`."""
        vulnerability_job = (
            IStore(VulnerabilityJob)
            .find(
                VulnerabilityJob,
                VulnerabilityJob.job_id == Job.id,
                VulnerabilityJob.job_type == cls.class_job_type,
                VulnerabilityJob.handler == handler,
            )
            .one()
        )
        return None if vulnerability_job is None else cls(vulnerability_job)

    def __repr__(self):
        """Returns an informative representation of the job."""
        parts = "%s for" % self.__class__.__name__
        parts += " handler: %s" % self.handler
        parts += ", metadata: %s" % self.metadata
        return "<%s>" % parts

    def _get_parser_importer(
        self,
        handler: VulnerabilityHandlerEnum,
        information_type: InformationType,
    ):
        """Decide which parser and importer to use

        :return: a tuple of (parser, importer) where parser is the function
        that gets a blob and returns a record and importer is the function that
        gets a record and imports it.
        """

        if handler == VulnerabilityHandlerEnum.SOSS:
            parser = SOSSRecord.from_yaml
            importer = SOSSImporter(
                information_type=information_type
            ).import_cve
        else:
            exception = VulnerabilityJobException("Handler not found")
            self.notifyUserError(exception)
            raise exception

        return parser, importer

    def run(self):
        """See `IRunnableJob`."""
        # InformationType is passed as a value as DBItem is not serializable
        information_type = InformationType.items[self.information_type]
        parser, importer = self._get_parser_importer(
            self.context.handler, information_type
        )

        # Get git repository
        git_lookup = getUtility(IGitLookup)
        repository = removeSecurityProxy(git_lookup.get(self.git_repository))
        if not repository:
            exception = VulnerabilityJobException("Git repository not found")
            self.notifyUserError(exception)
            raise exception

        # Get git reference
        ref = removeSecurityProxy(repository.getRefByPath(self.git_ref))
        if not ref:
            exception = VulnerabilityJobException("Git ref not found")
            self.notifyUserError(exception)
            raise exception

        # turnip API call to get added/modified files
        try:
            stats = getUtility(IGitHostingClient).getDiffStats(
                path=repository.getInternalPath(),
                old=self.import_since_commit_sha1,
                new=ref.commit_sha1,
                logger=logger,
            )
        except GitRepositoryScanFault:
            exception = VulnerabilityJobException(
                f"Git diff between {self.import_since_commit_sha1} and "
                f"{ref.commit_sha1} for {self.git_ref} not found"
            )
            self.notifyUserError(exception)
            raise exception

        files = [*stats.get("added", ()), *stats.get("modified", ())]
        for file in files:
            # Check if files that changed are in the desired path
            found_path = False
            for path in self.git_paths:
                if file.startswith(path):
                    found_path = True
                    break

            if not found_path:
                logger.debug(
                    f"[ImportVulnerabilityJob] {file} is not in git_paths"
                )
                continue

            cve_sequence = file.rsplit("/", maxsplit=1)[-1]
            if not CVE_PATTERN.match(cve_sequence):
                logger.debug(
                    f"[ImportVulnerabilityJob] {cve_sequence} is not a CVE "
                    "sequence"
                )
                continue

            success = False
            try:
                logger.debug(f"[ImportVulnerabilityJob] Getting {file}")
                blob = ref.getBlob(file)

                logger.debug(
                    f"[ImportVulnerabilityJob] Parsing {cve_sequence}"
                )
                record = parser(blob)

                bug, vulnerability = importer(record, cve_sequence)

                if bug and vulnerability:
                    success = True
                    self.metadata["result"]["succeeded"].append(cve_sequence)
            except (GitRepositoryScanFault, GitRepositoryBlobNotFound):
                # If there is a problem with git repository, we stop as we
                # won't be able to fetch more files
                raise VulnerabilityJobException(
                    f"Failed to get file from Git repository: {file}"
                )
            except Exception as e:
                self.notifyUserError(f"{cve_sequence}: {e}")
            finally:
                if not success:
                    self.metadata["result"]["failed"].append(cve_sequence)

    def notifyUserError(self, error):
        """Calls up and also saves the error text in this job's metadata.

        See `BaseRunnableJob`.
        """
        # This method is called when error is an instance of
        # self.user_error_types.
        super().notifyUserError(error)
        logger.error(error)
        error_description = self.metadata.get("result").get(
            "error_description", []
        )
        error_description.append(str(error))
        self.metadata["result"]["error_description"] = error_description

    def getOopsVars(self):
        """See `IRunnableJob`."""
        vars = super().getOopsVars()
        vars.extend(
            [
                ("vulnerabilityjob_job_id", self.context.id),
                ("vulnerability_job_type", self.context.job_type.title),
                ("handler", self.context.handler),
            ]
        )
        return vars
