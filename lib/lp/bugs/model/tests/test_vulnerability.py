# Copyright 2022 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

"""Tests for the vulnerability and related models."""
from datetime import timedelta
from pathlib import Path

from fixtures import MockPatch
from storm.store import Store
from testtools.matchers import MatchesStructure
from zope.component import getUtility
from zope.security.interfaces import Unauthorized
from zope.security.proxy import removeSecurityProxy

from lp.app.enums import InformationType
from lp.app.errors import (
    IncompatibleArguments,
    NotFoundError,
    SubscriptionPrivacyViolation,
    UserCannotUnsubscribePerson,
)
from lp.app.interfaces.launchpad import ILaunchpadCelebrities
from lp.app.interfaces.services import IService
from lp.bugs.enums import VulnerabilityHandlerEnum, VulnerabilityStatus
from lp.bugs.interfaces.buglink import IBugLinkTarget
from lp.bugs.interfaces.bugtask import BugTaskImportance
from lp.bugs.interfaces.vulnerability import (
    IVulnerability,
    IVulnerabilitySet,
    VulnerabilityChange,
)
from lp.bugs.interfaces.vulnerabilityjob import (
    IExportVulnerabilityJobSource,
    IImportVulnerabilityJobSource,
    VulnerabilityJobInProgress,
)
from lp.bugs.model.exportvulnerabilityjob import ExportVulnerabilityJob
from lp.bugs.model.importvulnerabilityjob import ImportVulnerabilityJob
from lp.bugs.model.vulnerability import (
    VULNERABILITY_EXPORT_HANDLER_ENABLED_FEATURE_FLAG,
    VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG,
    UnauthorizedVulnerabilityHandler,
)
from lp.bugs.model.vulnerabilitysubscription import VulnerabilitySubscription
from lp.code.tests.helpers import GitHostingFixture
from lp.registry.enums import BugSharingPolicy, TeamMembershipPolicy
from lp.services.webapp.authorization import check_permission
from lp.testing import (
    TestCaseWithFactory,
    admin_logged_in,
    anonymous_logged_in,
    api_url,
    feature_flags,
    person_logged_in,
    set_feature_flag,
    verifyObject,
)
from lp.testing.layers import DatabaseFunctionalLayer, LaunchpadZopelessLayer
from lp.testing.pages import webservice_for_person


def grant_access_to_non_public_vulnerability(vulnerability, person):
    distribution = removeSecurityProxy(vulnerability).distribution
    with person_logged_in(distribution.owner):
        getUtility(IService, "sharing").ensureAccessGrants(
            [person],
            distribution.owner,
            vulnerabilities=[vulnerability],
        )


class TestVulnerability(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def setUp(self):
        super().setUp()
        self.distribution = self.factory.makeDistribution()
        self.vulnerability = self.factory.makeVulnerability(
            distribution=self.distribution
        )

    def makeProprietaryDistribution(self):
        return self.factory.makeDistribution(
            bug_sharing_policy=BugSharingPolicy.PROPRIETARY
        )

    def makeProprietaryVulnerability(self, distribution=None):
        if distribution is None:
            distribution = self.makeProprietaryDistribution()
        return self.factory.makeVulnerability(
            distribution=distribution,
            information_type=InformationType.PROPRIETARY,
        )

    def test_Vulnerability_implements_IVulnerability(self):
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(verifyObject(IVulnerability, vulnerability))

    def test_Vulnerability_implements_IBugLinkTarget(self):
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(verifyObject(IBugLinkTarget, vulnerability))

    def test_Vulnerability_subscriptions_subscribers_empty_default(self):
        vulnerability = self.factory.makeVulnerability()
        self.assertEqual(0, vulnerability.subscribers.count())
        self.assertEqual(0, vulnerability.subscriptions.count())

    def test_public_vulnerability_visibleByUser(self):
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(vulnerability.visibleByUser(None))
        self.assertTrue(vulnerability.visibleByUser(self.factory.makePerson()))

    def test_non_public_vulnerability_visibleByUser(self):
        # XXX lgp171188 - We use the 'Proprietary' sharing policy
        # as an example non-public information_type and may have to
        # add tests for other non-public types in the future.
        distribution = self.makeProprietaryDistribution()
        vulnerability = self.makeProprietaryVulnerability(distribution)
        allowed_user = self.factory.makePerson()
        grant_access_to_non_public_vulnerability(
            vulnerability,
            allowed_user,
        )

        # Admin and Bug Importer can access to all non embargoed
        # vulnerabilities
        admin = getUtility(ILaunchpadCelebrities).admin
        bug_importer = getUtility(ILaunchpadCelebrities).bug_importer

        with person_logged_in(distribution.owner):
            self.assertFalse(vulnerability.visibleByUser(None))
            self.assertFalse(
                vulnerability.visibleByUser(self.factory.makePerson())
            )
            self.assertTrue(vulnerability.visibleByUser(allowed_user))
            self.assertTrue(vulnerability.visibleByUser(admin))
            self.assertTrue(vulnerability.visibleByUser(bug_importer))

    def test_embargoed_vulnerability_visibleByUser(self):
        """Launchpad bug importer and admins cant access embargoed
        vulnerabilities."""
        distribution = self.factory.makeDistribution(
            bug_sharing_policy=BugSharingPolicy.EMBARGOED_OR_PROPRIETARY
        )
        vulnerability = self.factory.makeVulnerability(
            distribution=distribution,
            information_type=InformationType.EMBARGOED,
        )
        admin = getUtility(ILaunchpadCelebrities).admin
        bug_importer = getUtility(ILaunchpadCelebrities).bug_importer

        with person_logged_in(distribution.owner):
            self.assertFalse(vulnerability.visibleByUser(None))
            self.assertFalse(
                vulnerability.visibleByUser(self.factory.makePerson())
            )
            self.assertFalse(vulnerability.visibleByUser(admin))
            self.assertFalse(vulnerability.visibleByUser(bug_importer))

    def test_setting_information_type_reconciles_access(self):
        mock_reconcile_method = self.useFixture(
            MockPatch(
                "lp.bugs.model.vulnerability.reconcile_access_for_artifacts"
            )
        ).mock
        vulnerability = self.factory.makeVulnerability()
        self.assertEqual(
            InformationType.PUBLIC, vulnerability.information_type
        )
        with person_logged_in(vulnerability.distribution.owner):
            vulnerability.information_type = InformationType.PROPRIETARY
        mock_reconcile_method.assert_called_with(
            [vulnerability],
            InformationType.PROPRIETARY,
            [vulnerability.distribution],
        )

    def test_getSubscription_person_is_None(self):
        self.assertIsNone(
            self.factory.makeVulnerability().getSubscription(None)
        )

    def test_getSubscription_person_is_not_subscribed(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertIsNone(vulnerability.getSubscription(person))

    def test_getSubscription_person_is_subscribed(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        subscription = VulnerabilitySubscription(
            person=person, vulnerability=vulnerability, subscribed_by=person
        )
        self.assertEqual(subscription, vulnerability.getSubscription(person))

    def test_hasSubscription(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertFalse(vulnerability.hasSubscription(person))
        VulnerabilitySubscription(
            person=person,
            vulnerability=vulnerability,
            subscribed_by=person,
        )
        self.assertTrue(vulnerability.hasSubscription(person))

    def test_userCanBeSubscribed_person_public_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(vulnerability.userCanBeSubscribed(person))

    def test_userCanBeSubscribed_person_non_public_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability(
                self.makeProprietaryDistribution()
            )
        )
        self.assertTrue(vulnerability.userCanBeSubscribed(person))

    def test_userCanBeSubscribed_public_vulnerability_non_open_team(self):
        team = self.factory.makeTeam(
            membership_policy=TeamMembershipPolicy.RESTRICTED
        )
        self.assertFalse(team.anyone_can_join())
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(vulnerability.userCanBeSubscribed(team))

    def test_userCanBeSubscribed_non_public_vulnerability_non_open_team(self):
        team = self.factory.makeTeam(
            membership_policy=TeamMembershipPolicy.RESTRICTED,
        )
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability(
                self.makeProprietaryDistribution()
            )
        )
        self.assertTrue(vulnerability.userCanBeSubscribed(team))

    def test_userCanBeSubscribed_non_public_vulnerability_open_team(self):
        team = removeSecurityProxy(self.factory.makeTeam())
        self.assertTrue(team.anyone_can_join())
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability(
                self.makeProprietaryDistribution()
            )
        )
        self.assertFalse(vulnerability.userCanBeSubscribed(team))

    def test_subscribe_person_to_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, vulnerability.distribution.owner)
        self.assertTrue(vulnerability.hasSubscription(person))

        non_public_vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability()
        )
        distribution_owner = non_public_vulnerability.distribution.owner
        with person_logged_in(distribution_owner):
            non_public_vulnerability.subscribe(
                person,
                distribution_owner,
            )
            self.assertTrue(non_public_vulnerability.hasSubscription(person))

    def test_subscribe_open_team_non_public_vulnerability(self):
        open_team = self.factory.makeTeam()
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability()
        )
        distribution_owner = vulnerability.distribution.owner
        with person_logged_in(distribution_owner):
            self.assertRaises(
                SubscriptionPrivacyViolation,
                vulnerability.subscribe,
                open_team,
                distribution_owner,
            )

    def test_subscribe_open_team_public_vulnerability(self):
        open_team = self.factory.makeTeam()
        vulnerability = self.factory.makeVulnerability()
        self.assertFalse(vulnerability.hasSubscription(open_team))
        vulnerability.subscribe(open_team, vulnerability.distribution.owner)
        self.assertTrue(vulnerability.hasSubscription(open_team))

    def test_subscribe_subscribing_a_person_with_existing_subscription(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(
            person,
            vulnerability.distribution.owner,
        )
        self.assertTrue(vulnerability.hasSubscription(person))
        self.assertEqual(
            1,
            Store.of(vulnerability)
            .find(
                VulnerabilitySubscription,
                VulnerabilitySubscription.person == person,
                VulnerabilitySubscription.vulnerability == vulnerability,
            )
            .count(),
        )
        vulnerability.subscribe(
            person,
            vulnerability.distribution.owner,
        )
        self.assertTrue(vulnerability.hasSubscription(person))
        self.assertEqual(
            1,
            Store.of(vulnerability)
            .find(
                VulnerabilitySubscription,
                VulnerabilitySubscription.person == person,
                VulnerabilitySubscription.vulnerability == vulnerability,
            )
            .count(),
        )

        vulnerability2 = removeSecurityProxy(
            self.makeProprietaryVulnerability()
        )
        distribution_owner = vulnerability2.distribution.owner
        with person_logged_in(distribution_owner):
            vulnerability2.subscribe(person, distribution_owner)
            self.assertTrue(vulnerability2.hasSubscription(person))
            vulnerability2.subscribe(person, distribution_owner)
            self.assertTrue(vulnerability2.hasSubscription(person))

    def test_subscribing_to_non_public_vulnerability_makes_it_visible(self):
        person = self.factory.makePerson()
        vulnerability = self.makeProprietaryVulnerability()
        distribution_owner = removeSecurityProxy(
            vulnerability
        ).distribution.owner
        with person_logged_in(person):
            self.assertFalse(check_permission("launchpad.View", vulnerability))
            self.assertFalse(check_permission("launchpad.Edit", vulnerability))

        with person_logged_in(distribution_owner):
            vulnerability.subscribe(person, distribution_owner)
        with person_logged_in(person):
            self.assertTrue(check_permission("launchpad.View", vulnerability))
            self.assertFalse(check_permission("launchpad.Edit", vulnerability))

    def test_subscribers_subscriptions(self):
        person1 = self.factory.makePerson()
        person2 = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertEqual(0, vulnerability.subscriptions.count())
        self.assertEqual(0, vulnerability.subscribers.count())
        vulnerability.subscribe(person1, person1)
        vulnerability.subscribe(person2, person2)
        self.assertContentEqual({person1, person2}, vulnerability.subscribers)
        self.assertEqual(2, vulnerability.subscriptions.count())

    def test_unsubscribe_user_not_subscribed(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertFalse(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, person)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_unsubscribe_random_user_cannot_unsubscribe_a_subscriber(self):
        person = self.factory.makePerson()
        person2 = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, person)
        self.assertRaises(
            UserCannotUnsubscribePerson,
            vulnerability.unsubscribe,
            person,
            person2,
        )

    def test_unsubscribe_self(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, person)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_vulnerability_creator_can_unsubscribe_subscribers(self):
        creator_member = self.factory.makePerson()
        person = self.factory.makePerson()
        creator = self.factory.makeTeam(members=[creator_member])
        vulnerability = self.factory.makeVulnerability(creator=creator)
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, creator_member)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_distribution_owner_can_unsubscribe_subscribers(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, vulnerability.distribution.owner)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_distribution_security_admins_can_unsubscribe_subscribers(self):
        person = self.factory.makePerson()
        security_member = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        with person_logged_in(vulnerability.distribution.owner):
            vulnerability.distribution.security_admin = self.factory.makeTeam(
                members=[security_member]
            )
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, security_member)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_creator_of_a_subscription_can_unsubscribe_the_subscriber(self):
        person = self.factory.makePerson()
        person2 = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person2, person)
        self.assertTrue(vulnerability.hasSubscription(person2))
        vulnerability.unsubscribe(person2, person)
        self.assertFalse(vulnerability.hasSubscription(person2))

    def test_admins_can_unsubscribe_subscribers(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(
            person, getUtility(ILaunchpadCelebrities).admin.teamowner
        )
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_unsubscribe_removes_visibility_of_non_public_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability()
        )
        distribution_owner = vulnerability.distribution.owner
        with person_logged_in(distribution_owner):
            vulnerability.subscribe(person, distribution_owner)

        with person_logged_in(person):
            self.assertTrue(check_permission("launchpad.View", vulnerability))
            vulnerability.unsubscribe(person, person)

        # Have to re-login again for the permission cache to get invalidated.
        with person_logged_in(person):
            self.assertFalse(check_permission("launchpad.View", vulnerability))

    def test_random_user_permissions(self):
        with person_logged_in(self.factory.makePerson()):
            self.assertTrue(
                check_permission("launchpad.View", self.vulnerability)
            )
            self.assertFalse(
                check_permission("launchpad.Edit", self.vulnerability)
            )

    def test_random_user_permissions_non_public_vulnerability(self):
        vulnerability = self.makeProprietaryVulnerability()
        with person_logged_in(self.factory.makePerson()):
            self.assertFalse(check_permission("launchpad.View", vulnerability))

    def test_user_can_view_shared_non_public_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = self.makeProprietaryVulnerability()
        grant_access_to_non_public_vulnerability(vulnerability, person)
        with person_logged_in(person):
            self.assertTrue(check_permission("launchpad.View", vulnerability))

    def test_admin_permissions(self):
        with admin_logged_in():
            self.assertTrue(
                check_permission("launchpad.View", self.vulnerability)
            )
            self.assertTrue(
                check_permission("launchpad.Edit", self.vulnerability)
            )

    def test_distribution_owner_permissions(self):
        with person_logged_in(self.distribution.owner):
            self.assertTrue(
                check_permission("launchpad.View", self.vulnerability)
            )
            self.assertTrue(
                check_permission("launchpad.Edit", self.vulnerability)
            )

    def test_security_admin_permissions(self):
        person = self.factory.makePerson()
        security_team = self.factory.makeTeam(members=[person])
        with person_logged_in(self.distribution.owner):
            self.distribution.security_admin = security_team

        with person_logged_in(person):
            self.assertTrue(
                check_permission("launchpad.Edit", self.vulnerability)
            )

    def test_anonymous_permissions(self):
        with anonymous_logged_in():
            self.assertTrue(
                check_permission("launchpad.View", self.vulnerability)
            )
            self.assertFalse(
                check_permission("launchpad.Edit", self.vulnerability)
            )
        distribution = self.factory.makeDistribution(
            bug_sharing_policy=BugSharingPolicy.PROPRIETARY
        )
        vulnerability = self.factory.makeVulnerability(
            distribution=distribution,
            information_type=InformationType.PROPRIETARY,
        )
        with anonymous_logged_in():
            self.assertFalse(check_permission("launchpad.View", vulnerability))
            self.assertFalse(check_permission("launchpad.Edit", vulnerability))

    def test_edit_vulnerability_security_admin(self):
        person = self.factory.makePerson()
        security_team = self.factory.makeTeam(members=[person])
        vulnerability = self.factory.makeVulnerability(
            distribution=self.distribution
        )
        cve = self.factory.makeCVE("2022-1234")
        with person_logged_in(self.distribution.owner):
            self.distribution.security_admin = security_team

        with person_logged_in(security_team):
            vulnerability.cve = cve
            vulnerability.status = VulnerabilityStatus.ACTIVE
            self.assertThat(
                vulnerability,
                MatchesStructure.byEquality(
                    cve=cve, status=VulnerabilityStatus.ACTIVE
                ),
            )


class TestVulnerabilityActivity(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def test_vulnerability_activity_changes(self):
        vulnerability = self.factory.makeVulnerability()
        changer = self.factory.makePerson()
        activity = self.factory.makeVulnerabilityActivity(
            vulnerability=vulnerability, changer=None
        )
        with person_logged_in(changer):
            self.assertTrue(
                VulnerabilityChange.DESCRIPTION, activity.what_changed
            )


class TestVulnerabilitySet(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def test_VulnerabilitySet_implements_IVulnerabilitySet(self):
        vulnerabilitySet = getUtility(IVulnerabilitySet)
        self.assertTrue(verifyObject(IVulnerabilitySet, vulnerabilitySet))

    def test_bugVulnerabilityCount(self):
        # vulnerability3 linked bugs will not be reflected
        # in computations of linked bugs on
        # vulnerability 1 and 2

        vulnerability1 = self.factory.makeVulnerability()
        vulnerability2 = self.factory.makeVulnerability()
        vulnerability3 = self.factory.makeVulnerability()
        bug1 = self.factory.makeBug()
        bug2 = self.factory.makeBug()
        initial_number = len(vulnerability1.bugs)
        with admin_logged_in():
            vulnerability1.linkBug(bug1)
            vulnerability3.linkBug(bug1)
            vulnerability3.linkBug(bug2)

        self.assertEqual(initial_number + 1, len(vulnerability1.bugs))

        with admin_logged_in():
            vulnerability2.linkBug(bug2)
        self.assertEqual(
            initial_number + 2,
            (len(vulnerability1.bugs) + len(vulnerability2.bugs)),
        )

        with admin_logged_in():
            vulnerability2.linkBug(bug1)
        self.assertEqual(
            initial_number + 3,
            (len(vulnerability1.bugs) + len(vulnerability2.bugs)),
        )

        with admin_logged_in():
            vulnerability1.unlinkBug(bug1)
            vulnerability2.unlinkBug(bug2)
            vulnerability2.unlinkBug(bug1)
        self.assertEqual(
            initial_number,
            (len(vulnerability1.bugs) + len(vulnerability2.bugs)),
        )

    def test_access_reconciled_after_creating_a_vulnerability(self):
        mock_reconcile_method = self.useFixture(
            MockPatch(
                "lp.bugs.model.vulnerability.reconcile_access_for_artifacts"
            )
        ).mock
        distribution = self.factory.makeDistribution()
        creator = self.factory.makePerson()
        vulnerability = getUtility(IVulnerabilitySet).new(
            distribution=distribution,
            status=VulnerabilityStatus.NEEDS_TRIAGE,
            importance=BugTaskImportance.UNDECIDED,
            creator=creator,
        )
        mock_reconcile_method.assert_called_with(
            [vulnerability], vulnerability.information_type, [distribution]
        )

    def test_findByIds(self):
        person = self.factory.makePerson()
        proprietary_distribution = self.factory.makeDistribution(
            bug_sharing_policy=BugSharingPolicy.PROPRIETARY,
        )
        vulnerability1 = removeSecurityProxy(self.factory.makeVulnerability())
        vulnerability2 = removeSecurityProxy(
            self.factory.makeVulnerability(
                distribution=proprietary_distribution,
                information_type=InformationType.PROPRIETARY,
            )
        )
        vulnerability3 = removeSecurityProxy(
            self.factory.makeVulnerability(
                distribution=proprietary_distribution,
                information_type=InformationType.PROPRIETARY,
            )
        )
        grant_access_to_non_public_vulnerability(vulnerability2, person)
        vulnerability_set = getUtility(IVulnerabilitySet)
        self.assertContentEqual(
            {vulnerability1, vulnerability2, vulnerability3},
            vulnerability_set.findByIds(
                [
                    vulnerability1.id,
                    vulnerability2.id,
                    vulnerability3.id,
                ]
            ),
        )
        self.assertContentEqual(
            {vulnerability1, vulnerability2},
            vulnerability_set.findByIds(
                [
                    vulnerability1.id,
                    vulnerability2.id,
                    vulnerability3.id,
                ],
                visible_by_user=person,
            ),
        )


class TestVulnerabilitySetImportData(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def setUp(self):
        super().setUp()
        self.requester = self.factory.makePerson()
        self.handler = VulnerabilityHandlerEnum.SOSS
        self.git_ref = "ref/heads/main"
        self.git_paths = ["cves"]
        self.information_type = InformationType.PROPRIETARY
        self.team = self.factory.makeTeam(members=[self.requester])

    def test_importData(self):
        """Test that we can create a ImportVulnerabilityJob using importData
        method.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        with person_logged_in(self.requester):
            getUtility(IVulnerabilitySet).importData(
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )

            job = getUtility(IImportVulnerabilityJobSource).get(self.handler)
            naked_job = removeSecurityProxy(job)
            self.assertIsInstance(naked_job, ImportVulnerabilityJob)
            self.assertEqual(naked_job.git_repository, repo.id)
            self.assertEqual(naked_job.git_ref, self.git_ref)
            self.assertEqual(naked_job.git_paths, self.git_paths)
            self.assertEqual(
                naked_job.information_type, self.information_type.value
            )
            self.assertEqual(naked_job.import_since_commit_sha1, None)

    def test_importData_uct_handler(self):
        """Test that we can create a ImportVulnerabilityJob using importData
        method and the UCT handler.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "UCT"
        )

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        ubuntu_team = getUtility(ILaunchpadCelebrities).ubuntu.owner
        requester = self.factory.makePerson(member_of=(ubuntu_team,))

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        handler = VulnerabilityHandlerEnum.UCT
        with person_logged_in(self.requester):
            getUtility(IVulnerabilitySet).importData(
                requester,
                handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )

            job = getUtility(IImportVulnerabilityJobSource).get(handler)
            naked_job = removeSecurityProxy(job)
            self.assertIsInstance(naked_job, ImportVulnerabilityJob)
            self.assertEqual(naked_job.git_repository, repo.id)
            self.assertEqual(naked_job.git_ref, self.git_ref)
            self.assertEqual(naked_job.git_paths, self.git_paths)
            self.assertEqual(
                naked_job.information_type, self.information_type.value
            )
            self.assertEqual(naked_job.import_since_commit_sha1, None)

    def test_importData_multiple_handlers(self):
        """Test that the feature flag allows to create ImportVulnerabilityJob
        for multiple handlers.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "UCT SOSS"
        )

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        ubuntu_team = getUtility(ILaunchpadCelebrities).ubuntu.owner
        requester = self.factory.makePerson(member_of=(ubuntu_team,))
        self.factory.makeDistribution(name="soss", owner=requester)

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        handlers = [
            VulnerabilityHandlerEnum.SOSS,
            VulnerabilityHandlerEnum.UCT,
        ]
        for handler in handlers:
            with person_logged_in(self.requester):
                getUtility(IVulnerabilitySet).importData(
                    requester,
                    handler,
                    repo,
                    self.git_ref,
                    self.git_paths,
                    self.information_type,
                    import_since_commit_sha1=None,
                )

                job = getUtility(IImportVulnerabilityJobSource).get(handler)
                naked_job = removeSecurityProxy(job)
                self.assertIsInstance(naked_job, ImportVulnerabilityJob)
                self.assertEqual(naked_job.handler, handler)

    def test_importData_feature_flag_disabled(self):
        """Test that if the feature flag is disabled it raises the
        NotImplementedError exception."""

        # All parameters None, feature flag is the first check
        self.assertRaisesWithContent(
            NotImplementedError,
            "Vulnerability import API is currently disabled for "
            f"'{self.handler}'",
            getUtility(IVulnerabilitySet).importData,
            None,
            self.handler,
            *(None,) * 5,
        )

    def test_importData_git_repo_unauthorized(self):
        """Test that a user cannot create a ImportVulnerabilityJob for a git
        repository that is not visible for that user.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        repo = self.factory.makeGitRepository(
            information_type=InformationType.PRIVATESECURITY
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        self.assertRaises(
            Unauthorized,
            getUtility(IVulnerabilitySet).importData,
            self.requester,
            self.handler,
            repo,
            self.git_ref,
            self.git_paths,
            self.information_type,
            import_since_commit_sha1=None,
        )

    def test_importData_handler_unauthorized(self):
        """Test that we cannot create a ImportVulnerabilityJob if the user is
        not authorized to use the handler.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss")

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        self.assertRaisesWithContent(
            UnauthorizedVulnerabilityHandler,
            f"You don't have enough rights to use {self.handler}",
            getUtility(IVulnerabilitySet).importData,
            self.requester,
            self.handler,
            repo,
            self.git_ref,
            self.git_paths,
            self.information_type,
            import_since_commit_sha1=None,
        )

    def test_importData_information_type_private(self):
        """Test that we cannot create a ImportVulnerabilityJob when
        information_type is public but the git repository is private.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        information_type = InformationType.PUBLIC
        with person_logged_in(self.requester):
            self.assertRaisesWithContent(
                IncompatibleArguments,
                "information_type must be PRIVATE when importing from a "
                "private git repository",
                getUtility(IVulnerabilitySet).importData,
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                information_type,
                import_since_commit_sha1=None,
            )

    def test_importData_wrong_git_ref(self):
        """Test that we cannot create a ImportVulnerabilityJob when git_ref is
        not in the git repository.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        with person_logged_in(self.requester):
            self.assertRaisesWithContent(
                NotFoundError,
                "'wrong-git-ref does not exist in the specified git "
                "repository'",
                getUtility(IVulnerabilitySet).importData,
                self.requester,
                self.handler,
                repo,
                "wrong-git-ref",
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )

    def test_importData_wrong_import_since_commit_sha1(self):
        """Test that we can create a ImportVulnerabilityJob when
        import_since_commit_sha1 is not in git_ref. The job will check that
        later.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        import_since_commit_sha1 = "1" * 40
        with person_logged_in(self.requester):
            getUtility(IVulnerabilitySet).importData(
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1,
            )

            job = getUtility(IImportVulnerabilityJobSource).get(self.handler)
            naked_job = removeSecurityProxy(job)
            self.assertIsInstance(naked_job, ImportVulnerabilityJob)
            self.assertEqual(naked_job.git_repository, repo.id)
            self.assertEqual(naked_job.git_ref, self.git_ref)
            self.assertEqual(naked_job.git_paths, self.git_paths)
            self.assertEqual(
                naked_job.information_type, self.information_type.value
            )
            self.assertEqual(
                naked_job.import_since_commit_sha1, import_since_commit_sha1
            )

    def test_importData_duplicated(self):
        """Test that we cannot create a duplicated ImportVulnerabilityJob
        if there is already a peding one for the same handler.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        vulnerability_set = getUtility(IVulnerabilitySet)
        with person_logged_in(self.requester):
            vulnerability_set.importData(
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )

            self.assertRaises(
                VulnerabilityJobInProgress,
                vulnerability_set.importData,
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )

    def test_importData_duplicated_suspended(self):
        """Test that we can create a duplicated ImportVulnerabilityJob
        if the existing job is suspended for the same handler.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        vulnerability_set = getUtility(IVulnerabilitySet)
        with person_logged_in(self.requester):
            vulnerability_set.importData(
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )

        import_job = getUtility(IImportVulnerabilityJobSource).get(
            self.handler
        )
        import_job.job.suspend()

        with person_logged_in(self.requester):
            vulnerability_set.importData(
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )

    def test_importData_duplicated_old_job(self):
        """Test that we can create a a new ImportVulnerabilityJob if there is
        a pending one for the same handler but it is older than twice the
        task's soft_time_limit
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        repo = self.factory.makeGitRepository(
            owner=self.team, information_type=InformationType.USERDATA
        )

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        vulnerability_set = getUtility(IVulnerabilitySet)
        with person_logged_in(self.requester):
            vulnerability_set.importData(
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )
        import_job = getUtility(IImportVulnerabilityJobSource).get(
            self.handler
        )
        removeSecurityProxy(import_job.job).date_created -= timedelta(hours=5)

        with person_logged_in(self.requester):
            vulnerability_set.importData(
                self.requester,
                self.handler,
                repo,
                self.git_ref,
                self.git_paths,
                self.information_type,
                import_since_commit_sha1=None,
            )


class TestVulnerabilitySetExportData(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def setUp(self):
        super().setUp()
        self.requester = self.factory.makePerson()
        self.handler = VulnerabilityHandlerEnum.SOSS

    def test_exportData(self):
        """Test that we can create a ExportVulnerabilityJob using exportData
        method.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_EXPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        with person_logged_in(self.requester):
            getUtility(IVulnerabilitySet).exportData(
                self.requester,
                self.handler,
                None,
            )

        job = getUtility(IExportVulnerabilityJobSource).get(self.handler)
        naked_job = removeSecurityProxy(job)
        self.assertIsInstance(naked_job, ExportVulnerabilityJob)
        self.assertEqual(naked_job.handler, self.handler)

    def test_exportData_feature_flag_disabled(self):
        """Test that if the feature flag is disabled it raises the
        NotImplementedError exception."""

        # All parameters None, feature flag is the first check
        self.assertRaisesWithContent(
            NotImplementedError,
            "Vulnerability export API is currently disabled for "
            f"'{self.handler}'",
            getUtility(IVulnerabilitySet).exportData,
            self.requester,
            self.handler,
            None,
        )

    def test_exportData_handler_unauthorized(self):
        """Test that we cannot create a ExportVulnerabilityJob if the user is
        not authorized to use the handler.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_EXPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss")

        self.assertRaisesWithContent(
            UnauthorizedVulnerabilityHandler,
            f"You don't have enough rights to use {self.handler}",
            getUtility(IVulnerabilitySet).exportData,
            self.requester,
            self.handler,
            None,
        )

    def test_exportData_duplicated(self):
        """Test that we cannot create a duplicated ExportVulnerabilityJob
        if there is already a peding one for the same handler.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_EXPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        vulnerability_set = getUtility(IVulnerabilitySet)
        with person_logged_in(self.requester):
            vulnerability_set.exportData(
                self.requester,
                self.handler,
                None,
            )

            self.assertRaises(
                VulnerabilityJobInProgress,
                vulnerability_set.exportData,
                self.requester,
                self.handler,
                None,
            )

    def test_exportData_duplicated_suspended(self):
        """Test that we can create a new ExportVulnerabilityJob if there is
        a suspended one for the same handler.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_EXPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        vulnerability_set = getUtility(IVulnerabilitySet)
        with person_logged_in(self.requester):
            vulnerability_set.exportData(
                self.requester,
                self.handler,
                None,
            )

        export_job = getUtility(IExportVulnerabilityJobSource).get(
            self.handler
        )
        export_job.job.suspend()

        with person_logged_in(self.requester):
            vulnerability_set.exportData(
                self.requester,
                self.handler,
                None,
            )

    def test_exportData_duplicated_old_job(self):
        """Test that we can create a new ExportVulnerabilityJob if there is
        a pending job for the same handler that is more than twice the
        task's soft_time_limit
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_EXPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        self.factory.makeDistribution(name="soss", owner=self.requester)

        vulnerability_set = getUtility(IVulnerabilitySet)
        with person_logged_in(self.requester):
            vulnerability_set.exportData(
                self.requester,
                self.handler,
                None,
            )

        export_job = getUtility(IExportVulnerabilityJobSource).get(
            self.handler
        )
        removeSecurityProxy(export_job.job).date_created -= timedelta(hours=5)

        with person_logged_in(self.requester):
            vulnerability_set.exportData(
                self.requester,
                self.handler,
                None,
            )


class TestVulnerabilitySetWebService(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def setUp(self):
        super().setUp()
        self.vulnerability_set = getUtility(IVulnerabilitySet)
        self.vulnerability_set_url = api_url(self.vulnerability_set)
        self.requester = self.factory.makePerson()
        self.handler = VulnerabilityHandlerEnum.SOSS
        self.factory.makeDistribution(name="soss", owner=self.requester)
        self.team = self.factory.makeTeam(members=[self.requester])
        self.git_paths = ["cves"]
        self.information_type = InformationType.PROPRIETARY
        self.git_ref = "ref/heads/main"

    def test_importData_webservice_required_arguments_missing(self):
        """Test that importData webservice requires missing arguments."""
        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_post(
            self.vulnerability_set_url,
            "importData",
        )
        self.assertEqual(400, response.status)
        self.assertEqual(
            {
                "git_paths: Required input is missing.",
                "git_ref: Required input is missing.",
                "git_repository: Required input is missing.",
                "handler: Required input is missing.",
            },
            set(response.body.decode().split("\n")),
        )

    def test_importData_webservice(self):
        """Test that we can create a ImportVulnerabilityJob using the
        webservice.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        repo = self.factory.makeGitRepository(owner=self.team)
        repo_url = api_url(repo)

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_post(
            self.vulnerability_set_url,
            "importData",
            handler=self.handler.title,
            git_repository=repo_url,
            git_ref=self.git_ref,
            git_paths=self.git_paths,
            information_type=self.information_type.title,
            import_since_commit_sha1=None,
        )
        self.assertEqual(200, response.status)

    def test_importData_webservice_feature_flag_disabled(self):
        """Test that we cannot create a ImportVulnerabilityJob using the
        webservice when the vulnerability import API is disabled.
        """
        repo = self.factory.makeGitRepository(owner=self.team)
        repo_url = api_url(repo)

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_post(
            self.vulnerability_set_url,
            "importData",
            handler=self.handler.title,
            git_repository=repo_url,
            git_ref=self.git_ref,
            git_paths=self.git_paths,
            information_type=self.information_type.title,
            import_since_commit_sha1=None,
        )
        self.assertEqual(500, response.status)
        self.assertEqual(
            "Vulnerability import API is currently disabled for "
            f"'{self.handler}'",
            response.body.decode().split("\n")[0],
        )

    def test_importData_webservice_git_repo_unauthorized(self):
        """Test that we cannot create a ImportVulnerabilityJob using the
        webservice when the git repository is not visible by the user.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_IMPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        owner = self.factory.makePerson()
        repo = self.factory.makeGitRepository(
            owner=owner,
            information_type=InformationType.PRIVATESECURITY,
        )
        with person_logged_in(owner):
            repo_url = api_url(repo)

        self.factory.makeGitRefs(
            repository=repo,
            paths=[self.git_ref],
        )

        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_post(
            self.vulnerability_set_url,
            "importData",
            handler=self.handler.title,
            git_repository=repo_url,
            git_ref=self.git_ref,
            git_paths=self.git_paths,
            information_type=self.information_type.title,
            import_since_commit_sha1=None,
        )

        # 401 Unauthorized
        self.assertEqual(401, response.status)

    def test_exportData_webservice_required_arguments_missing(self):
        """Test that exportData webservice requires missing arguments."""
        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_post(
            self.vulnerability_set_url,
            "exportData",
        )
        self.assertEqual(400, response.status)
        self.assertEqual(
            {
                "handler: Required input is missing.",
            },
            set(response.body.decode().split("\n")),
        )

    def test_exportData_webservice(self):
        """Test that we can create a ExportVulnerabilityJob using the
        webservice.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_EXPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_post(
            self.vulnerability_set_url,
            "exportData",
            handler=self.handler.title,
        )
        self.assertEqual(200, response.status)

    def test_exportData_webservice_feature_flag_disabled(self):
        """Test that we cannot create a ExportVulnerabilityJob using the
        webservice when the vulnerability import API is disabled.
        """
        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_post(
            self.vulnerability_set_url,
            "exportData",
            handler=self.handler.title,
        )
        self.assertEqual(500, response.status)
        self.assertEqual(
            "Vulnerability export API is currently disabled for "
            f"'{self.handler}'",
            response.body.decode().split("\n")[0],
        )

    def test_exportData_webservice_handler_unauthorized(self):
        """Test that we can create a ExportVulnerabilityJob using the
        webservice.
        """
        self.useContext(feature_flags())
        set_feature_flag(
            VULNERABILITY_EXPORT_HANDLER_ENABLED_FEATURE_FLAG, "SOSS"
        )

        user_unauthorized = self.factory.makePerson()

        webservice = webservice_for_person(
            user_unauthorized,
            default_api_version="devel",
        )
        response = webservice.named_post(
            self.vulnerability_set_url,
            "exportData",
            handler=self.handler.title,
        )
        self.assertEqual(500, response.status)
        self.assertEqual(
            f"You don't have enough rights to use {self.handler}",
            response.body.decode().split("\n")[0],
        )

    def test_getImports_webservice_required_arguments_missing(self):
        """Test that getImports webservice requires missing arguments."""
        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_get(
            self.vulnerability_set_url,
            "getImports",
        )
        self.assertEqual(400, response.status)
        self.assertEqual(
            {
                "handler: Required input is missing.",
            },
            set(response.body.decode().split("\n")),
        )

    def test_getImports_webservice(self):
        """Test that we can get Import jobs using the webservice."""
        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_get(
            self.vulnerability_set_url,
            "getImports",
            handler=self.handler.title,
        )
        self.assertEqual(200, response.status)

    def test_getExports_webservice_required_arguments_missing(self):
        """Test that getExports webservice requires missing arguments."""
        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_get(
            self.vulnerability_set_url,
            "getExports",
        )
        self.assertEqual(400, response.status)
        self.assertEqual(
            {
                "handler: Required input is missing.",
            },
            set(response.body.decode().split("\n")),
        )

    def test_getExports_webservice(self):
        """Test that we can get Export jobs using the webservice."""

        webservice = webservice_for_person(
            self.requester,
            default_api_version="devel",
        )
        response = webservice.named_get(
            self.vulnerability_set_url,
            "getExports",
            handler=self.handler.title,
        )
        self.assertEqual(200, response.status)


class TestVulnerabilityGetJobs(TestCaseWithFactory):
    """Tests for collecting export vulnerability job info."""

    layer = LaunchpadZopelessLayer

    def setUp(self):
        super().setUp()
        self.requester = self.factory.makePerson()
        self.handler = VulnerabilityHandlerEnum.SOSS

        self.cve_path = (
            Path(__file__).parent
            / ".."
            / ".."
            / "scripts"
            / "soss"
            / "tests"
            / "sampledata"
            / "CVE-2025-1979"
        )
        self.repository = self.factory.makeGitRepository()
        self.refs = self.factory.makeGitRefs(
            repository=self.repository,
            paths=("ref/heads/main", "ref/tags/v1.0"),
        )

    def _create_import_job(self):
        """Helper to create a single ImportVulnerabilityJob."""
        with open(self.cve_path, encoding="utf-8") as file:
            self.useFixture(
                GitHostingFixture(
                    blob=file.read(),
                    refs=self.refs,
                    diff_stats={"added": ["cves/CVE-2025-1979"]},
                )
            )

        job = getUtility(IImportVulnerabilityJobSource).create(
            handler=VulnerabilityHandlerEnum.SOSS,
            git_repository=self.repository.id,
            git_ref="ref/tags/v1.0",
            git_paths=["cves"],
            information_type=InformationType.PRIVATESECURITY.value,
        )

        return job

    def _create_export_job(self):
        """Helper to create a single ExportVulnerabilityJob.

        Ensures an import job has already been completed before export.
        """
        import_job = self._create_import_job()

        import_job.job.start()
        import_job.run()
        import_job.job.complete()

        job = getUtility(IExportVulnerabilityJobSource).create(
            handler=VulnerabilityHandlerEnum.SOSS,
        )

        return job

    def test_getImports(self):
        """Test getImports function runs as expected."""
        self.factory.makeCVE("2025-1979")
        self.factory.makeDistribution(name="soss", owner=self.requester)

        job = self._create_import_job()

        job.run()

        result = getUtility(IVulnerabilitySet).getImports(
            self.requester,
            self.handler,
        )

        self.assertEqual(1, len(result))
        result = result[0]

        naked_job = removeSecurityProxy(job)

        self.assertEqual(result["request"], naked_job.metadata["request"])
        self.assertEqual(result["result"], naked_job.metadata["result"])

        job_details = {
            "created_at": naked_job.job.date_created,
            "started_at": naked_job.job.date_started,
            "finished_at": naked_job.job.date_finished,
        }

        self.assertEqual(result["job_details"], job_details)

    def test_getImports_full(self):
        """Test retrieval of exactly 10 import jobs."""
        self.factory.makeCVE("2025-1979")
        self.factory.makeDistribution(name="soss", owner=self.requester)

        jobs = []

        for _ in range(10):
            job = self._create_import_job()
            jobs.append(job)
            job.job.start()
            job.run()
            job.job.complete()

        jobs = jobs[::-1]  # Reverse since the results will be reversed

        results = getUtility(IVulnerabilitySet).getImports(
            self.requester,
            self.handler,
        )

        self.assertEqual(10, len(results))

        # Validate all results against jobs
        for job, result in zip(jobs, results):
            naked_job = removeSecurityProxy(job)

            self.assertEqual(result["request"], naked_job.metadata["request"])
            self.assertEqual(result["result"], naked_job.metadata["result"])

            job_details = {
                "created_at": naked_job.job.date_created,
                "started_at": naked_job.job.date_started,
                "finished_at": naked_job.job.date_finished,
            }

            self.assertEqual(result["job_details"], job_details)

    def test_getImports_more_than_10(self):
        """Test that only the last 10 import jobs are returned."""
        self.factory.makeCVE("2025-1979")
        self.factory.makeDistribution(name="soss", owner=self.requester)

        jobs = []

        for _ in range(11):
            job = self._create_import_job()
            jobs.append(job)
            job.job.start()
            job.run()
            job.job.complete()

        # Reverse and delete the first job since the results will use
        # the last 10 jobs in reverse
        jobs = jobs[-1::-1]

        results = getUtility(IVulnerabilitySet).getImports(
            self.requester,
            self.handler,
        )

        self.assertEqual(10, len(results))

        for job, result in zip(jobs, results):
            naked_job = removeSecurityProxy(job)

            self.assertEqual(result["request"], naked_job.metadata["request"])
            self.assertEqual(result["result"], naked_job.metadata["result"])

            job_details = {
                "created_at": naked_job.job.date_created,
                "started_at": naked_job.job.date_started,
                "finished_at": naked_job.job.date_finished,
            }

            self.assertEqual(result["job_details"], job_details)

    def test_getImports_unauthenticated(self):
        """Test imports fail when requester lacks handler rights."""
        self.factory.makeCVE("2025-1979")
        self.factory.makeDistribution(name="soss")

        job = self._create_import_job()

        job.run()

        self.assertRaisesWithContent(
            UnauthorizedVulnerabilityHandler,
            f"You don't have enough rights to use {self.handler}",
            getUtility(IVulnerabilitySet).getImports,
            self.requester,
            self.handler,
        )

    def test_getExports(self):
        """Test getExports function runs as expected."""
        self.factory.makeCVE("2025-1979")
        self.factory.makeDistribution(name="soss", owner=self.requester)

        job = self._create_export_job()

        job.run()

        result = getUtility(IVulnerabilitySet).getExports(
            self.requester,
            self.handler,
        )

        self.assertEqual(1, len(result))
        result = result[0]

        naked_job = removeSecurityProxy(job)

        self.assertEqual(result["request"], naked_job.metadata["request"])
        self.assertEqual(result["result"], naked_job.metadata["result"])
        self.assertEqual(result["data"], naked_job.metadata["data"])

        job_details = {
            "created_at": naked_job.job.date_created,
            "started_at": naked_job.job.date_started,
            "finished_at": naked_job.job.date_finished,
        }

        self.assertEqual(result["job_details"], job_details)

    def test_getExports_full(self):
        """Test retrieval of exactly 10 export jobs."""
        self.factory.makeCVE("2025-1979")
        self.factory.makeDistribution(name="soss", owner=self.requester)

        jobs = []

        for _ in range(10):
            job = self._create_export_job()
            jobs.append(job)
            job.job.start()
            job.run()
            job.job.complete()

        jobs = jobs[::-1]  # Reverse since the results will be reversed

        results = getUtility(IVulnerabilitySet).getExports(
            self.requester,
            self.handler,
        )

        self.assertEqual(10, len(results))

        for job, result in zip(jobs, results):
            naked_job = removeSecurityProxy(job)

            self.assertEqual(result["request"], naked_job.metadata["request"])
            self.assertEqual(result["result"], naked_job.metadata["result"])
            self.assertEqual(result["data"], naked_job.metadata["data"])

            job_details = {
                "created_at": naked_job.job.date_created,
                "started_at": naked_job.job.date_started,
                "finished_at": naked_job.job.date_finished,
            }

            self.assertEqual(result["job_details"], job_details)

    def test_getExports_more_than_10(self):
        """Test that only the last 10 export jobs are returned."""
        self.factory.makeCVE("2025-1979")
        self.factory.makeDistribution(name="soss", owner=self.requester)

        jobs = []

        for _ in range(11):
            job = self._create_export_job()
            jobs.append(job)
            job.job.start()
            job.run()
            job.job.complete()

        # Reverse and delete the first job since the results will use
        # the last 10 jobs in reverse
        jobs = jobs[-1::-1]

        results = getUtility(IVulnerabilitySet).getExports(
            self.requester,
            self.handler,
        )

        self.assertEqual(10, len(results))

        for job, result in zip(jobs, results):
            naked_job = removeSecurityProxy(job)

            self.assertEqual(result["request"], naked_job.metadata["request"])
            self.assertEqual(result["result"], naked_job.metadata["result"])
            self.assertEqual(result["data"], naked_job.metadata["data"])

            job_details = {
                "created_at": naked_job.job.date_created,
                "started_at": naked_job.job.date_started,
                "finished_at": naked_job.job.date_finished,
            }

            self.assertEqual(result["job_details"], job_details)

    def test_getExports_unauthenticated(self):
        """Test exports fail when requester lacks handler rights."""
        self.factory.makeCVE("2025-1979")
        self.factory.makeDistribution(name="soss")

        job = self._create_export_job()

        job.run()

        self.assertRaisesWithContent(
            UnauthorizedVulnerabilityHandler,
            f"You don't have enough rights to use {self.handler}",
            getUtility(IVulnerabilitySet).getExports,
            self.requester,
            self.handler,
        )
