# Copyright 2025 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

__all__ = [
    "ExportVulnerabilityJob",
]

import io
import logging
import os
import tempfile
import zipfile
from datetime import datetime, timedelta, timezone
from typing import List, Optional, Tuple

from zope.component import getUtility
from zope.interface import implementer, provider
from zope.security.proxy import removeSecurityProxy

from lp.bugs.enums import VulnerabilityHandlerEnum
from lp.bugs.interfaces.vulnerabilityjob import (
    IExportVulnerabilityJob,
    IExportVulnerabilityJobSource,
    VulnerabilityJobException,
    VulnerabilityJobInProgress,
    VulnerabilityJobType,
)
from lp.bugs.model.bug import Bug as BugModel
from lp.bugs.model.vulnerability import HANDLER_DISTRIBUTION_MAP, Vulnerability
from lp.bugs.model.vulnerabilityjob import (
    VulnerabilityJob,
    VulnerabilityJobDerived,
)
from lp.bugs.scripts.soss.sossexport import SOSSExporter
from lp.bugs.scripts.svthandler import SVTExporter, SVTRecord
from lp.bugs.scripts.uct.uctexport import UCTExporter
from lp.registry.interfaces.distribution import IDistributionSet
from lp.registry.model.distribution import Distribution
from lp.services.config import config
from lp.services.database.interfaces import IPrimaryStore, IStore
from lp.services.job.interfaces.job import JobStatus
from lp.services.job.model.job import Job
from lp.services.librarian.interfaces import ILibraryFileAliasSet
from lp.services.utils import utc_now

EXPIRATION_WEEK_INTERVAL = 4
PROCESSED_CVE_LOG_INTERVAL = 500
logger = logging.getLogger(__name__)


@implementer(IExportVulnerabilityJob)
@provider(IExportVulnerabilityJobSource)
class ExportVulnerabilityJob(VulnerabilityJobDerived):
    class_job_type = VulnerabilityJobType.EXPORT_DATA

    user_error_types = (VulnerabilityJobException,)

    # This is a known slow task that will exceed the timeouts for
    # the normal job queue, so put it on a queue with longer timeouts
    task_queue = "launchpad_job_slow"

    soft_time_limit = timedelta(minutes=120)
    lease_duration = timedelta(minutes=120)

    config = config.IExportVulnerabilityJobSource

    @property
    def sources(self):
        return self.metadata.get("request").get("sources")

    @property
    def error_description(self):
        return self.metadata.get("result").get("error_description")

    @classmethod
    def create(
        cls,
        handler,
        sources: Optional[List[str]] = None,
    ):
        """Create a new `ExportVulnerabilityJob`.

        :param handler: What handler to use for importing the data. Can be one
            of a group of predefined classes (SOSS, UCT, ...).
        :param sources: A list of sources to export from. Gets used depending
            on the handler.
        """
        store = IPrimaryStore(VulnerabilityJob)

        vulnerability_job = store.find(
            VulnerabilityJob,
            VulnerabilityJob.job_id == Job.id,
            VulnerabilityJob.job_type == cls.class_job_type,
            VulnerabilityJob.handler == handler,
            Job._status.is_in((JobStatus.WAITING, JobStatus.RUNNING)),
            # If the job was scheduled more than twice the time limit of the
            # job, we allow a new one to be created.
            Job.date_created
            > datetime.now(timezone.utc) - 2 * cls.soft_time_limit,
        ).one()

        if vulnerability_job is not None:
            raise VulnerabilityJobInProgress(cls(vulnerability_job))

        # Schedule the initialization.
        metadata = {
            "request": {
                "sources": sources if sources is not None else [],
            },
            "result": {
                "error_description": [],
                "succeeded": [],
                "failed": [],
            },
            "data": {
                "export_link": "",
            },
        }

        vulnerability_job = VulnerabilityJob(
            handler, cls.class_job_type, metadata
        )
        store.add(vulnerability_job)
        derived_job = cls(vulnerability_job)
        derived_job.celeryRunOnCommit()
        IStore(VulnerabilityJob).flush()
        return derived_job

    @classmethod
    def get(cls, handler):
        """See `IExportVulnerabilityJob`."""
        vulnerability_job = (
            IStore(VulnerabilityJob)
            .find(
                VulnerabilityJob,
                VulnerabilityJob.job_id == Job.id,
                VulnerabilityJob.job_type == cls.class_job_type,
                VulnerabilityJob.handler == handler,
            )
            .one()
        )
        return None if vulnerability_job is None else cls(vulnerability_job)

    def __repr__(self):
        """Returns an informative representation of the job."""
        parts = "%s for" % self.__class__.__name__
        parts += " handler: %s" % self.handler
        parts += ", metadata: %s" % self.metadata
        return "<%s>" % parts

    def _get_exporter(
        self,
        handler: VulnerabilityHandlerEnum,
    ) -> SVTExporter:
        """Decide which exporter to use

        :return: a tuple of (parser, importer) where parser is the function
        that gets a blob and returns a record and importer is the function that
        gets a record and imports it.
        """

        if handler == VulnerabilityHandlerEnum.SOSS:
            return SOSSExporter()
        elif handler == VulnerabilityHandlerEnum.UCT:
            return UCTExporter()
        else:
            exception = VulnerabilityJobException(
                f"Handler '{handler}' not found"
            )
            self.notifyUserError(exception)
            raise exception

    def _get_distribution(self, handler) -> Distribution:
        distribution_name = HANDLER_DISTRIBUTION_MAP.get(handler)

        if not distribution_name:
            exception = VulnerabilityJobException(
                f"Handler '{handler}' not found"
            )
            self.notifyUserError(exception)
            raise exception

        distribution = removeSecurityProxy(
            getUtility(IDistributionSet).getByName(distribution_name)
        )

        return distribution

    def _get_bug(
        self, vulnerability: Vulnerability
    ) -> Tuple[Optional[BugModel], Optional[Vulnerability]]:
        bugs = vulnerability.bugs

        if not bugs:
            logger.debug(
                f"[ExportVulnerabilityJob] CVE-{vulnerability.cve.sequence} "
                "does not have a bug attached."
            )
            return None

        if len(bugs) > 1:
            logger.debug(
                f"[ExportVulnerabilityJob] CVE-{vulnerability.cve.sequence} "
                "has more than one bug attached."
            )
            return None

        bug = bugs[0]

        return removeSecurityProxy(bug)

    def run(self):
        """See `IRunnableJob`."""

        exporter = self._get_exporter(self.context.handler)
        distribution = self._get_distribution(self.context.handler)
        distribution_vulnerability_set = (
            distribution.getVulnerabilitiesVisibleToUser(
                user=None, check_permissions=False
            )
        )

        logger.debug(
            f"[ExportVulnerabilityJob] Getting {self.context.handler} CVEs to"
            "export and storing them in Records"
        )

        # Log progress every PROCESSED_CVE_LOG_INTERVAL CVEs
        num_parsed_cves = 0

        exported_cves: List[Tuple[SVTRecord, str]] = []
        for vul in distribution_vulnerability_set:

            bug = self._get_bug(vul)

            if not bug:
                exception = VulnerabilityJobException(
                    f"CVE-{vul.cve.sequence} either has no "
                    "bug or has more than one."
                )
                self.notifyUserError(exception)
                continue

            try:
                record = exporter.to_record(bug, vul)
            except ValueError as e:
                self.notifyUserError(e)
                continue

            if record is None:
                exception = VulnerabilityJobException(
                    f"CVE-{vul.cve.sequence} couldn't be converted"
                )
                self.notifyUserError(exception)
                continue

            exported_cves.append((record, record.candidate))

            if num_parsed_cves % PROCESSED_CVE_LOG_INTERVAL == 0:
                logger.debug(
                    f"[ExportVulnerabilityJob] Processed "
                    f"{num_parsed_cves} CVEs so far..."
                )
            num_parsed_cves += 1

        logger.debug(
            f"[ExportVulnerabilityJob] Finished processing CVEs. "
            f"Processed {num_parsed_cves} CVEs in total."
        )

        if len(exported_cves) == 0:
            exception = VulnerabilityJobException("No CVEs to export")
            self.notifyUserError(exception)
            raise exception

        # Log progress every PROCESSED_CVE_LOG_INTERVAL CVEs
        num_written_cves = 0

        # Create a temporary folder
        with tempfile.TemporaryDirectory() as temp_dir:

            logger.debug(
                "[ExportVulnerabilityJob] Writing CVEs to temporary "
                f"directory {temp_dir}"
            )

            for record, cve_name in exported_cves:
                file_path = os.path.join(temp_dir, cve_name)

                with open(file_path, "w") as f:
                    f.write(record.to_str())

            # Create a zip archive of the temp folder
            buf = io.BytesIO()
            with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zipf:
                logger.debug(
                    "[ExportVulnerabilityJob] Compressing CVEs to zip"
                )
                for dirpath, _, filenames in os.walk(temp_dir):
                    for filename in filenames:
                        try:
                            filepath = os.path.join(dirpath, filename)
                            arcname = os.path.relpath(
                                filepath, temp_dir
                            )  # relative path inside zip
                            zipf.write(filepath, arcname)
                        except Exception as e:
                            logger.error(
                                f"Error adding file {filename} to zip: {e}"
                            )
                            self.metadata["result"]["failed"].append(filename)
                            self.notifyUserError(e)
                        else:
                            self.metadata["result"]["succeeded"].append(
                                filename
                            )

                        if num_written_cves % PROCESSED_CVE_LOG_INTERVAL == 0:
                            logger.debug(
                                f"[ExportVulnerabilityJob] Wrote "
                                f"{num_written_cves} CVEs to zip so far..."
                            )
                        num_written_cves += 1

        logger.debug(
            f"[ExportVulnerabilityJob] Finished writing CVEs to zip. "
            f"Wrote {num_written_cves} CVEs in total."
        )

        zip_name = f"exported_vulnerabilities_{self.context.id}.zip"
        contentType = "application/zip"
        file_size = buf.getbuffer().nbytes

        expires = utc_now() + timedelta(weeks=EXPIRATION_WEEK_INTERVAL)

        # Reset buffer position to the beginning since librarian will read it.
        buf.seek(0)

        logger.debug("[ExportVulnerabilityJob] Writing zip to librarian")
        lfa = getUtility(ILibraryFileAliasSet).create(
            name=zip_name,
            size=file_size,
            file=buf,
            contentType=contentType,
            expires=expires,
        )

        self.metadata["data"]["export_link"] = lfa.getURL()

    def notifyUserError(self, error):
        """Calls up and also saves the error text in this job's metadata.

        See `BaseRunnableJob`.
        """
        # This method is called when error is an instance of
        # self.user_error_types.
        super().notifyUserError(error)
        logger.error(error)
        error_description = self.metadata.get("result").get(
            "error_description", []
        )
        error_description.append(str(error))
        self.metadata["result"]["error_description"] = error_description

    def getOopsVars(self):
        """See `IRunnableJob`."""
        vars = super().getOopsVars()
        vars.extend(
            [
                ("vulnerabilityjob_job_id", self.context.id),
                ("vulnerability_job_type", self.context.job_type.title),
                ("handler", self.context.handler),
            ]
        )
        return vars
