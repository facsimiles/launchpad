# Copyright 2025 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

__all__ = [
    "ExportVulnerabilityJob",
]

import io
import logging
import os
import tempfile
import zipfile
from datetime import timedelta
from typing import List, Optional, Tuple

from zope.component import getUtility
from zope.interface import implementer, provider
from zope.security.proxy import removeSecurityProxy

from lp.app.enums import InformationType
from lp.bugs.enums import VulnerabilityHandlerEnum
from lp.bugs.interfaces.cve import ICveSet
from lp.bugs.interfaces.vulnerabilityjob import (
    IExportVulnerabilityJob,
    IExportVulnerabilityJobSource,
    VulnerabilityJobException,
    VulnerabilityJobInProgress,
    VulnerabilityJobType,
)
from lp.bugs.model.bug import Bug as BugModel
from lp.bugs.model.cve import Cve as CveModel
from lp.bugs.model.vulnerability import Vulnerability
from lp.bugs.model.vulnerabilityjob import (
    VulnerabilityJob,
    VulnerabilityJobDerived,
)
from lp.bugs.scripts.soss.models import SOSSRecord
from lp.bugs.scripts.soss.sossexport import SOSSExporter
from lp.registry.interfaces.distribution import IDistributionSet
from lp.registry.model.distribution import Distribution
from lp.services.config import config
from lp.services.database.interfaces import IPrimaryStore, IStore
from lp.services.job.interfaces.job import JobStatus
from lp.services.job.model.job import Job
from lp.services.librarian.interfaces import ILibraryFileAliasSet
from lp.services.utils import utc_now

DISTRIBUTION_NAME = "soss"
EXPIRATION_WEEK_INTERVAL = 1
logger = logging.getLogger(__name__)


@implementer(IExportVulnerabilityJob)
@provider(IExportVulnerabilityJobSource)
class ExportVulnerabilityJob(VulnerabilityJobDerived):
    class_job_type = VulnerabilityJobType.EXPORT_DATA

    user_error_types = (VulnerabilityJobException,)

    config = config.IExportVulnerabilityJobSource

    def __init__(self, job):
        super().__init__(job)
        self.cve_set = getUtility(ICveSet)
        self.soss = getUtility(IDistributionSet).getByName(DISTRIBUTION_NAME)

    @property
    def sources(self):
        return self.metadata.get("request").get("sources")

    @property
    def information_type(self):
        return self.metadata.get("request").get("information_type")

    @property
    def error_description(self):
        return self.metadata.get("result").get("error_description")

    @classmethod
    def create(
        cls,
        handler,
        sources: Optional[List[str]] = None,
        information_type=InformationType.PRIVATESECURITY.value,
    ):
        """Create a new `ExportVulnerabilityJob`.

        :param handler: What handler to use for importing the data. Can be one
            of a group of predefined classes (SOSS, UCT, ...).
        :param sources: A list of sources to export from. Gets used depending
            on the handler.
        """
        store = IPrimaryStore(VulnerabilityJob)

        vulnerability_job = store.find(
            VulnerabilityJob,
            VulnerabilityJob.job_id == Job.id,
            VulnerabilityJob.job_type == cls.class_job_type,
            VulnerabilityJob.handler == handler,
            Job._status.is_in(
                (JobStatus.WAITING, JobStatus.RUNNING, JobStatus.SUSPENDED)
            ),
        ).one()

        if vulnerability_job is not None:
            raise VulnerabilityJobInProgress(cls(vulnerability_job))

        # Schedule the initialization.
        metadata = {
            "request": {
                "sources": sources if sources is not None else [],
                "information_type": information_type,
            },
            "result": {
                "error_description": [],
                "succeeded": [],
                "failed": [],
            },
            "data": {
                "export_link": "",
            },
        }

        vulnerability_job = VulnerabilityJob(
            handler, cls.class_job_type, metadata
        )
        store.add(vulnerability_job)
        derived_job = cls(vulnerability_job)
        derived_job.celeryRunOnCommit()
        IStore(VulnerabilityJob).flush()
        return derived_job

    @classmethod
    def get(cls, handler):
        """See `IExportVulnerabilityJob`."""
        vulnerability_job = (
            IStore(VulnerabilityJob)
            .find(
                VulnerabilityJob,
                VulnerabilityJob.job_id == Job.id,
                VulnerabilityJob.job_type == cls.class_job_type,
                VulnerabilityJob.handler == handler,
            )
            .one()
        )
        return None if vulnerability_job is None else cls(vulnerability_job)

    def __repr__(self):
        """Returns an informative representation of the job."""
        parts = "%s for" % self.__class__.__name__
        parts += " handler: %s" % self.handler
        parts += ", metadata: %s" % self.metadata
        return "<%s>" % parts

    def _get_exporter_to_record(
        self,
        handler: VulnerabilityHandlerEnum,
        information_type: InformationType = InformationType.PRIVATESECURITY,
    ):
        """Decide which parser and importer to use

        :return: a tuple of (parser, importer) where parser is the function
        that gets a blob and returns a record and importer is the function that
        gets a record and imports it.
        """

        if handler == VulnerabilityHandlerEnum.SOSS:
            exporter = SOSSExporter(
                information_type=information_type
            ).to_record
        else:
            exception = VulnerabilityJobException("Handler not found")
            self.notifyUserError(exception)
            raise exception

        return exporter

    def _get_bug_and_vulnerability(
        self, cve: CveModel, distribution: Distribution
    ) -> Tuple[Optional[BugModel], Optional[Vulnerability]]:

        vulnerability = cve.getDistributionVulnerability(distribution)

        if not vulnerability:
            logger.debug(
                f"[ExportVulnerabilityJob] CVE-{cve.sequence} "
                "does not have a vulnerability attached."
            )
            return None, None

        bugs = vulnerability.bugs

        if not bugs:
            logger.debug(
                f"[ExportVulnerabilityJob] CVE-{cve.sequence} "
                "does not have a bug attached."
            )
            return None, None

        if len(bugs) > 1:
            logger.debug(
                f"[ExportVulnerabilityJob] CVE-{cve.sequence} "
                "has more than one bug attached."
            )
            return None, None

        bug = bugs[0]

        return removeSecurityProxy(bug), vulnerability

    def run(self):
        """See `IRunnableJob`."""

        information_type = InformationType.items[self.information_type]
        export_to_record = self._get_exporter_to_record(
            self.context.handler,
            information_type,
        )

        logger.debug(
            "[ExportVulnerabilityJob] Getting CVEs to export and storing "
            "them in Records"
        )

        exported_cves: List[Tuple[SOSSRecord, str]] = []
        for cve in self.cve_set:

            bug, vulnerability = self._get_bug_and_vulnerability(
                cve, self.soss
            )

            if not bug or not vulnerability:
                continue

            try:
                record = export_to_record(cve, self.soss, bug, vulnerability)
            except ValueError as e:
                self.notifyUserError(e)
                continue

            if record is None:
                continue

            exported_cves.append((record, record.candidate))

        if exported_cves == []:
            exception = VulnerabilityJobException("No CVEs to export")
            self.notifyUserError(exception)
            return

        # Create a temporary folder
        with tempfile.TemporaryDirectory() as temp_dir:

            logger.debug(
                "[ExportVulnerabilityJob] Writing CVEs to temporary "
                f"directory {temp_dir}"
            )

            for record, cve_name in exported_cves:
                file_path = os.path.join(temp_dir, cve_name)

                with open(file_path, "w") as f:

                    logger.debug(
                        "[ExportVulnerabilityJob] Writing CVE %s to file %s",
                        cve_name,
                        file_path,
                    )

                    f.write(record.to_yaml())

            # Create a zip archive of the temp folder
            buf = io.BytesIO()
            with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zipf:
                logger.debug(
                    "[ExportVulnerabilityJob] Compressing CVEs to zip"
                )
                for dirpath, _, filenames in os.walk(temp_dir):
                    for filename in filenames:
                        try:
                            logger.debug(
                                "[ExportVulnerabilityJob] Compressing file %s",
                                filename,
                            )
                            filepath = os.path.join(dirpath, filename)
                            arcname = os.path.relpath(
                                filepath, temp_dir
                            )  # relative path inside zip
                            zipf.write(filepath, arcname)
                        except Exception as e:
                            logger.error(
                                f"Error adding file {filename} to zip: {e}"
                            )
                            self.metadata["result"]["failed"].append(filename)
                            self.notifyUserError(e)
                        else:
                            self.metadata["result"]["succeeded"].append(
                                filename
                            )

        zip_name = f"exported_vulnerabilities_{self.context.id}.zip"
        contentType = "application/zip"
        file_size = buf.getbuffer().nbytes

        expires = utc_now() + timedelta(weeks=EXPIRATION_WEEK_INTERVAL)

        # Reset buffer position to the beginning since librarian will read it.
        buf.seek(0)

        logger.debug("[ExportVulnerabilityJob] Writing zip to librarian")
        lfa = getUtility(ILibraryFileAliasSet).create(
            name=zip_name,
            size=file_size,
            file=buf,
            contentType=contentType,
            expires=expires,
        )

        self.metadata["data"]["export_link"] = lfa.getURL()

    def notifyUserError(self, error):
        """Calls up and also saves the error text in this job's metadata.

        See `BaseRunnableJob`.
        """
        # This method is called when error is an instance of
        # self.user_error_types.
        super().notifyUserError(error)
        logger.error(error)
        error_description = self.metadata.get("result").get(
            "error_description", []
        )
        error_description.append(str(error))
        self.metadata["result"]["error_description"] = error_description

    def getOopsVars(self):
        """See `IRunnableJob`."""
        vars = super().getOopsVars()
        vars.extend(
            [
                ("vulnerabilityjob_job_id", self.context.id),
                ("vulnerability_job_type", self.context.job_type.title),
                ("handler", self.context.handler),
            ]
        )
        return vars
